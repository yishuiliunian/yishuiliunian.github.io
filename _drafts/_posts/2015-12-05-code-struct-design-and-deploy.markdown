---
layout: post
title: "近一段时间从事建构设计的总结"
date: 2015-12-05T18:51:09+08:00
categories: iOS
---

从11月份开始自己一部分工作重心开始往架构设计上进行转移。这个也是目前项目在质量上的要求决定的。这段时间和同事一起讨论如何设计和实施结构，也算是有些想法。写下来，算是总结，也在博客上和大家交流一下，欢迎拍砖。

当然，按照我以前的习惯，说点什么的时候，首先明确的是定义。但这一次可能有点例外了，因为关于“架构”，但目前为止业界也没有给出一个明确的定义。目前比较流行的有：组成派和决策派。

按照组成派的说法：软件系统的架构就是用来将系统描述为计算机组件以及组件之间的交互。Mary Shaw和David Garlan给出了更为明确的定义：软件架构={组件(component),连接件(connector)，约束(constrain)}。组件可以是独立的程序，比如数据库服务器，也可是子系统、框架、模块、类等不同粒度的软件单元，它们共同的特点都是承担一定的计算职责。连接件可以是过程调用、管道、RPC或者Web Service等，用于表示组件之间的相互作用。约束一般为对象连接时的规则，或指明构件连接的形式和条件。例如，上层构件可要求下层构件的服务，反之不行；两对象不得递规地发送消息；代码复制迁移的一致性约束；什么条件下此种连接无效等。

而决策派认为软件架构是软件一些重要方面决策的集合。这种说法的典型代表是RUP中对于软件架构的定义：
软件架构包含了关于以下问题的重要决策：

1. 软件系统的组织；
2. 选择组成系统的结构元素和它们之间的接口，以及当这些元素相互协作时所体现的行为；
3. 如何组合这些元素，使它们逐渐组成更大的子系统；
4. 用于指导这个系统组织的架构风格：这些元素以及他们的接口、协作和组合。


当然从其他的一些书籍中我们还能看到这样的一些描述：架构即约束、风险驱动的架构设计、质量驱动的架构设计。。。。。

无论哪种定义其实我感觉都在围绕着几个事情再讲：抽象、分治、知识[引自《恰如其分的软件架构》]。

抽象：对当前的问题域进行概括和精炼。尽可能的缩小问题空间。这个是个建模的过程。通过合理的抽象活动，对当前问题域进行建模。

分治：对将庞杂的大问题，拆解成相对规模较小的子问题。比如说要从北京到南极洲，可以拆解成从北京到美国，从美国到澳大利亚，从澳大利亚到南极，三个子问题。在编程中，我们常常使用的函数，类就是封装了一个个的子问题的解决方案。分治的必然结果就是职责划分，当然实现职责划分的方式，包括刚才说的函数、类。甚至包括模块和子系统等等方式。现在我们常用的Cocoapods包管理工具，就是一个很好的分治的例子。他讲IOS开发中常遇到的一些问题和需求，划分成一个个的pod。

知识：任何一个架构都不是凭空出来的。其必然是为了解决某个特定的问题而存在。为了解决这个问题，我们可能会提取出一些特定的知识来为解决改问题服务。当然这里的知识不止是像数据库技术，IO优化技巧这样的东西。甚至是，一些我们的app中遇到的特定问题，比如之前博客中说道的在SDK设计的时候，SDK在运行时污染了宿主环境，我们使用类似于VM的方式来解决。还有，使我们关于一些决定性的问题形成的公式，比如将布局代码统一写在layoutSubViews函数里面等等。


好了，上面说的三点是比较虚的东西。但是，这三点却是支撑我进行架构分析、设计和实施的核心思想。有点万剑归宗的意思。我个人认为，且不管结构设计的流派如何，上述三点及其衍生出来的方法论，对于架构设计来讲犹如巨鼎之三足。后面的整个过程中我们会反反复复的提及哈。

##二分

首先我们会面对一个问题，什么是架构设计的最小单元？是类吗，还是函数，又或者是模块，子系统？最开始着手进行设计的时候，这是困扰我的最大的一个问题。到底应该从那个层次开始入手，或者架构的设计应该精细到什么地步，是否需要画出每个类图？现在面前混沌一片，不知如何插足。

> 有一天，盘古突然醒了。他见周围一片漆黑，就抡起大斧头，朝眼前的黑暗猛劈过去。只听一声巨响，混沌一片的东西渐渐分开了。轻而清的东西，缓缓上升，变成了天；重而浊的东西，慢慢下降，变成了地。

先给他来一斧子进行分治吧，将问题分成两部分：宏观设计和微观设计。大的模块划分属于宏观的事情，小的类图属于微观的事情。从宏观入手确定整体的结构，而后在入手确定微观的事情。

使用分治之后，顿时觉得有点找到方向的感觉。因为之前写过不少APP，对于一个app甚至是写一个sdk的东西大概齐需要些什么功能模块，心里有点底。比如都会用到数据库，网络，UI的一些特效库之类的东西。还都会针对自己独有的业务逻辑做一些封装。这些相对来说都是比较大的模块了。对其划分和规划是宏观层面要做的事情之一。


##宏观架构设计

###结构

> 机制与策略分离，实现与接口分离

这是引自《UNIX》编程艺术一书中的一句话。所谓机制即是实现某一类业务通用的功能，当被抽离出来的时候，其有很大的概率与业务无关了。比如我们常用的sqlite，当其独立成一个库的时候，很难说它和QQ的业务逻辑有关系，和钱包的业务逻辑有关系。它只是完成了结构化数据存储这个事情。而所谓策略，即是我们怎样将机制应用在我们自己的业务逻辑中。这是分治的一个具体的实践方法。

之所以会在这里提到这句话，是因为我们可以通过这个策略进行纵向分层。来完成关注点隔离。业务开发的同学应该关注业务逻辑的实现就好了，底层的一些机制的稳定性和质量应当是又另一些同学负责的。这样机制对于业务侧的同学透明，策略对于机制的同学也透明。在关注点隔离的情况下，他们能够很好的去维护自己的东西，而无需去关注一些庞杂的东西。

同时结合领域建模的一些思想。反复应用机制与策略分离的策略。我们可以得到一个比较通用的宏观的分层。

![](http://ww1.sinaimg.cn/large/7df22103jw1eyp88iydwaj20f20hv0t8.jpg)

这个结构其实比较Common，可以在很多app或者sdk的设计中通用。其实我们这些是对模块之间的关系进行的梳理，而且主要是层次间的关系。可能这里会有同学问，为什么没有先去分模块呢？其实，iOS甚至是软件开发这个事情，经过这么多年前辈们的实践和总结。一些app该有哪些模块，基本上都比较确定了。很多分模块的事情，前人已经为我们做的很好了。尤其是iOS系统，很多模块apple都已经通过库的形式提供给我们了。比如管理地理位置的CoreLocation，管理界面的UIKit，比如进行结构化数据存储的sqlite（FMDB）和CoreData,进行数据解析的Mantle。

然后紧接着就是另外一个问题了，如何去实践和落实这个划分。

我们在管理多个模块的时候，发现了一个问题。虽然分模块带来了更加清晰的结构，和明确的模块间的职责划分。但是模块间是存在”依赖“的啊。比如UIKit依赖了CoreFoundation，CoreFoundation依赖了libObjc。而我们自己的模块中也会存在这种功能上的依赖关系。我们自己封装的网络库，依赖我们自己封装的模型解析库之类。于是，在落实上面这个划分的时候，我们碰到的第一个拦路虎就是“依赖”。

这是一个非常现实的问题，如果你没有处理好依赖关系。那么将会引入新的问题。比如之前我们的类库中就存在(->这个符号定义为依赖关系)：

~~~
A->B
B->C
C->A
C->B
....
~~~

这种依赖关系，先给他们总结个名字叫做循环依赖吧。这种循环依赖，加深了模块间的耦合。结果，我们如果想动一个模块，势必会对另外的模块造成影响。而另外的模块又会对其他模块造成影响。牵一发而动全身。

尤其是A->B,B->A这种循环依赖存在的时候，A模块打包依赖B模块修改后的打包，而B模块打包又依赖A模块修改的包。就死循环了，这个非常类似于多线程中死锁的问题。除了手工的强制，去释放锁，貌似没有更好的办法了。

因为我们规定：

1. **任何下层模块不得对上层模块依赖**
2. 在同一个层次中的模块避免产生循环依赖。

而在处理依赖关系的时候，现在业界最流行最牛叉的工具CocoaPods不得不被提及。除了模块关系（上传下载之外），pod处理的最好的问题就是模块间的依赖。这包括模块间功能依赖，版本依赖等等。然而其只是一个工具，如果我们模块间的关系没有理顺的话，他对于我们整个工程来讲也许可能会有帮倒忙的风险。我们就碰到了这样的问题。


对于如何实现模块划分我们这里有这么几个考量点：

1. 代码隔离，不同模块间的代码最好不要在一起
2. 模块可复用。能够以极小的成本集成到另外的工程当中。
3. 依赖管理，能够自动管理模块间的依赖。

这里可供我们选择的方式有：

1. 单工程，分目录
2. 每个模块一个工程，每个工程输出framework，通过管理framework来管理依赖。
3. 每个模块一个目录。需要依赖改模块的工程，引用模块源码。

在多人大规模协作的过程中现在比较流行的是第三种方法，也是Cocoapods实现的方法。而在有些企业内部，为了防止源码泄露，保证代码的安全性，使用较多的是第二种模式。对于团队规模较小，也就一两个人的时候，单工程分目录是使用最多的方式，也是相对比较高效的方式。而Cocoapods对于git的支持要远好于SVN。但是，比较无奈的我们因为”历史遗留“问题，从svn向git上切换是一个不被允许的事情。而svn的权限管理，相对git又比较严苛。所以我们在最开始采用了每个模块一个工程，工程输出framework的方式来管理。而源码直接走svn管理的方式来处理。但是经过一系列的实践后发现，这种方式对于七八个人的小团队来讲，有很大一部分时间花费在了和模块管理相关的事情上面，而不是代码本身相关的事情上面。对于人力来讲是一个不小的开销。

当然我们使用的工具链的基础也是Cocoapods，当初为了往Cocoapods上迁移也是费了不小的力气的。而由于这种代码分散在多个工程中的问题，导致当我们进行调试的时候，需要进行一些列繁琐的配置，而后还要跨模块调试，并且调试好的代码，还得在部署framework之后才能生效。当然这种方式对于大规模的团队来讲，从协作和安全性上都是比较OK的。但是对于七八个人的小团队来讲，引入了很多额外的流程，其代价有点过高。因而，我们决定往第三种方式上进行转移：

~~~
每个模块一个目录。对于对该模块有依赖的模块或工程，引用该模块的源码。而且对于模块来讲，主要以目录的方式存在，因为很多功能只是往外提供功能或者服务，因为其不需要可执行，不需要建工程。而其实对于我们整个SDK来讲，绝大多数的模块都是不可执行的。而对于app来讲，一般需要可执行的也就一个app本身而已。
~~~

###目录划分


###开发流程

####CI

####CD

##数据流转

其实对于目前市面上的app来讲数据流转是其最核心的内容。所以才会在各种各样的招聘帖中看到一条：熟悉http协议，熟悉tcp/ip协议。因为网络过程是最常见的数据流传（C/S）。而我们这里所谓的数据流程，是一个更加宽泛的概念。说的是数据在app内部的流通与转化。比如从服务器下来了一个NSData的数据，其内容是一个用户信息。这个NSData从这里开始，就在app内部开了他的旅程。先被按照JSON协议转化成了NSDictionary。然后又被赋值到了一个UserModel里面，之后UserModel存了数据库。同时，USerModel流转到了一个UserViewController，UserViewController拿到这个UserModel之后，根据他的信息，在界面上显示除了用户的姓名....


或许有人说这怎么感觉像是一个流程图呢。其实呢，这么说也多少有几分道理。我们可以把上述过程画成一个线路图，类似从北京到南极要经过哪些站点。从服务器到UI，一个数据要经过哪些关键环节。这个对于每一个app来讲可能都会有些不同。因为每一个环节代表了一个特殊的职责，有些app将json化和model解析放在了一起，有些将这些揉在了一起。有些中间还加入了数据正确性校验的过程，有些觉得可以信任服务器数据就没有正确性校验。而对于我们来讲，这个流程如下图：


这里我们可能会提起类似于MVC、MVP、MVVM、MVCS、FLUX....之类的常见架构名字。对于流程中关键环节的不同切分和归类方式，将会诞生出不一样的架构设计来。最后经过我们的讨论之后，我们将这些功能进行了如下划分。其整体的的结构非常类似于MVVM。

###又一个例子，网络库的设计

结合之前的经验我发现，以关键数据为焦点，关注其流传过程。是需要核心职责，并对其进行分割、合并、抽象等操作的比较好的方式。而在我们网络库的设计上，我们也应用了这个思想。



##关键问题

###把解决方案化成代码

> 约定大于配置 ——ROR

之前在看ROR的时候，印象最深的一句话就是约定大于配置。约定属于显性知识，你必须遵守，不然程序就跑不起来。而配置属于隐形知识，往往很多都有默认配置，当你需要调整个东西的时候，不了解配置将会无从入手。而在之后的很长一段时间里，我都非常信奉这一点。直到有一次接手别人的代码，他的代码里有太多”只有他自己知道的约定“，改动起来很痛苦。才恍然意识到：代码>约定。

> 代码>约定>配置>文档

我们进行架构设计，是为了追求更多的不变，追求将变化的部分对上层业务开发人员透明掉，让他们不用去为此而操心。

对于钱包SDK来讲现在最重要的约束是质量。


-----
欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注  
![](http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg)
