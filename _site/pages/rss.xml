<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>一水的技术博客</title>
    <link>http://dzpqzb.com</link>
    <description>iOS开发者，讲述一些关于OC、iOS、设计模式和架构的故事。欢迎关注微信公共账号IOS_Tips</description>
    
      <item>
        <title>如何进行技术方案优化</title>
        <link>http://dzpqzb.com/2015/11/28/optime-logic-method.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/28/optime-logic-method.html</guid>
        <pubDate>Sat, 28 Nov 2015 18:30:34 +0800</pubDate>
        <description>&lt;h1 id=&quot;section&quot;&gt;如何进行技术方案优化&lt;/h1&gt;

&lt;p&gt;首先这是一个很宏大的题目，我也只能窥其一斑。只说说自己的一些浅见和反思。因为之前有一段时间，在面对说要技术方案优化的时候，自己也有过一段不知所措的时期。后来才开始慢慢觉得自己找到点门道了，这片文章也算是自己的一个总结吧。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;什么是优化&lt;/h2&gt;

&lt;p&gt;首先我们先破题，来谈谈“优化”这个事情。通常情况下，我们说到优化的时候，往往会伴随着对之前系统的吐槽。或是不好用，或是性能低，或是用起来很麻烦。巴拉巴拉。是的，当我们对原先的系统有槽点的时候，我们会谈到“优化”。而“优化”的前提也是，之前已经有过一个东西存在，而且真对目前的场景应景不再适合。这个是有需要对原有系统进行调整，以满足当前的场景与需求。那么所谓优化即是：对原有系统进行有目的的改造。&lt;/p&gt;

&lt;p&gt;好吧，这听起来虽然说了什么，但其实什么都没说。因为这是一句大实话。&lt;/p&gt;

&lt;p&gt;but，我们仔细分析一下，我们要进行优化必须能够：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对原有系统的问题有所了解&lt;/li&gt;
  &lt;li&gt;了解目前场景和需求&lt;/li&gt;
  &lt;li&gt;有目的性的改造原有系统&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们来说一个我们通常会遇到的例子，也是在面试的时候会遇到的问题–“UItableView的性能优化”。其实每次有人问我这个问题，我内心都有千万只“草泥马”奔腾而过。没有具体的问题场景，只单单跑出来这样一个问题。是可以和他扯什么图片内存缓存了，避免圆角的使用了，预渲染，预加载了之类的东西。但是这些东西，真的对于在解决他们TableView卡顿的问题有效吗，不见得。套用《安娜卡列尼娜》一句话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;流畅的UItableView都是相似的，不流畅的UItableView各有各的不幸。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，吐槽到此为止。吐槽的目的是为了说明一点，你要进行优化，必须有一个特定的场景。在一个受限的范围内进行优化，因为这样目的是可控的。漫无边际的优化，和别人基于方法论的建议之类的东西，不一定对当前的问题有帮助。&lt;/p&gt;

&lt;p&gt;比如，之前我们在做的一个社交类的App中，首页使用了UItableView，老板说怎么用着这么卡顿。然后我们就开始了“优化”。&lt;/p&gt;

&lt;p&gt;首先，我们知道我们要优化的是第一个tab的tableview的滑动效率的问题。那总得有个监控的指标吧。对于程序猿来说，感觉这个不卡了，或者感觉这个卡，这个东西太模糊了。无法衡量啊。所以一定要量化。对于界面来讲就是大家常说的FPS，每秒帧率。于是我们测量了一下帧率，平均下来是25FPS。ou my god！的确是有点卡。&lt;/p&gt;

&lt;p&gt;然后我们知道对于ios来说如果能达到60FPS，那界面绝对不会有卡顿的感觉了。而很少有应用能达到这个水准。那么我们给自己设置了一个目标45FPS。btw,这个目标只是个阶段性目标。&lt;/p&gt;

&lt;p&gt;好了下面的过程，就是朝着这个目标前进了。当然我们知道，造成FPS较低的原因，一般都是主线程做了太多的事情，导致帧率降低。这只是个大方向。而对我们来讲，我们需要精准的知道，主线程都做了些什么事情，导致帧率降低。&lt;/p&gt;

&lt;p&gt;首先，我们发现的是，读取图片IO的过程发生在了主线程。IO过程一般是比较耗时的，于是我们像把该过程移到了后台线程中处理。发现帧率能够提高到33FPS，这还不够啊。革命尚未完成，同志仍需努力。&lt;/p&gt;

&lt;p&gt;之后的过程中，我们把布局预处理，还有圆角，数据预加载之类的事情做上去之后，终于基本达到45。阶段性目标完成。&lt;/p&gt;

&lt;p&gt;好了这是一个优化的例子：始于发现问题，止于目标达成。而重要的是其过程，描述问题！！！！&lt;/p&gt;

&lt;h2 id=&quot;or&quot;&gt;分析问题 (定性or定量)&lt;/h2&gt;

&lt;p&gt;其实，我一直比较坚信一句话：当你能够准确的描述一个问题的时候，你到解决问题就没剩几步了。比如刚才说的卡顿的问题，我们当时是这么描述的：图片读取发生了主线程，主线程中有一部分CPU片段用于文件读取和图片解码，造成主线程阻塞，从而导致帧率下降。当描述到这里的时候，解决方案就比较显而易见了，挪呗。搞到其他线程中之行。把主线程空出来。&lt;/p&gt;

&lt;p&gt;而上面的这个描述还只是一个定性的描述分析。只是阐述了现象。虽然能够解决了一个问题，但是对整体问题的贡献有多大，也未可知。所以我们可以当时完全可以这样描述：我们图片缓存在文件系统的平均大小是1MB，其读取时间为10.7ms，图片格式为jpeg，解码一个1M的图片耗时是60ms，而我们知道60FPS，每帧给主线程用来处理任务的CPU时间为17.7ms，也就说这个地方占用了大量CPU时间片来处理图片读与解码操作，从而造成了CPU阻塞，造成帧率没有达到60FPS。&lt;/p&gt;

&lt;p&gt;当我们使用定量的描述的时候，我们能够比较精确的知道，一个小问题，对于大问题来说到底意味着什么。而定量分析的方案中，当然包含了很多更多的细节信息，尤其是数据信息。这些也正是定量分析的优势所在。BUT，定量分析是一个非常耗时耗力的事情，你要拿到这么多的数据，你势必要付出很多时间，在采集这些数据上面。对于app开发来讲，除非公司给了足够的资源（尤其是时间），你才能像个研究者一样去采集这些数据，一般情况是，大概都会止步到定性分析这一步。其实这也是看具体问题而定了。&lt;/p&gt;

&lt;p&gt;不过无论你是使用定性分析的方式还是定量分析的方式。我们的目标是为了找到能够准确表述问题的方式，并且定位问题，以求找到解决方案。而为了达到这个目的一般情况下我们可以使用两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;你的编程功底和对iOS的了解程度都很深，那么完全可以从一些原理性的事情上去分析。我们称之为：逻辑分析法。&lt;/li&gt;
  &lt;li&gt;或许你的编程功底很深，或许很浅，或许你尝试分析而没有结果。那么可以使用改改代码试试的方法了。我们称之为：实验法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;逻辑分析法， 原理性分析&lt;/h3&gt;

&lt;p&gt;哈哈，套用马哲的一句话：事物是普遍联系的。既然是普遍联系的，不说必然存在因果，那么通过一定的逻辑分析。是可以找到他们之间的一些蛛丝马迹的关联的。这些关联或许可以解释一些什么。比如刚才卡顿的问题：原理就是主线程CPU被消耗过多，无法及时处理UI任务导致的。这只是一个例子。&lt;/p&gt;

&lt;p&gt;我们进行逻辑分析的目的，是为了找到我们的某些代码和问题之间的&lt;strong&gt;因果性&lt;/strong&gt;联系。就是说，我们能够明确知道造成UI卡顿的问题，就是因为IO的问题之类。这个话题说起来，比较深邃了。其中绝大部分实践的方法可以从《数理逻辑》这本书中找到。不过这是本讲数学的书，咱们得稍微换下脑子，把其中的定理，在编程中应用一下。因为我也只是意会了其中的某些东西，讲出来还没有那么功底。就只能麻烦各位自己去琢磨了。：）&lt;/p&gt;

&lt;h3 id=&quot;assume-action-response-test-assume&quot;&gt;实验法,Assume-Action-Response-Test-Assume&lt;/h3&gt;

&lt;p&gt;我称这个过称为&lt;strong&gt;AARTA&lt;/strong&gt;。这是一个一直往复的过程，在分析的过程中，你得一次次的重复这个过程来找到真正问题的所在。其实，这个方法比较常应用在改BUG这个场景上。其实如果从广义上讲，按照上面咱们对技术优化的定义，改bug也算是一种优化。只不过这个场景比价特殊而已。当无法准确的分析原理，或者当前程序的复杂性过高（低内聚高耦合）已经超出人脑的计算能力范围的时候，那么就可以“猜”了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7df22103jw1eyhrrytgv2j209408g3yn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;assume&quot;&gt;（1）假设 assume&lt;/h4&gt;

&lt;p&gt;根据以往的经验来，设定一个和问题域相关的假设。比如UI卡顿的问题，你怀疑是不是因为图片的问题呢。那么现在就假设是图片的问题！&lt;/p&gt;

&lt;h4 id=&quot;action&quot;&gt;（2） 尝试进行修改  action&lt;/h4&gt;

&lt;p&gt;既然假设是图片的问题，那么就把UIImageView从Cell上删掉吧。&lt;/p&gt;

&lt;h4 id=&quot;response&quot;&gt;（3）看程序的反馈 Response&lt;/h4&gt;

&lt;p&gt;重新运行一遍程序，看一下程序运行的效果。FPS是否有所改善，而且改善的幅度有多大。&lt;/p&gt;

&lt;h4 id=&quot;test&quot;&gt;（4）Test&lt;/h4&gt;

&lt;p&gt;根据，程序的反馈和我们预先设定的目标来判断一下，当前改动是否满足了我们设计的目标。如果有，那么你大概就找到了问题的一个原因。如果没有那么进行下一步。&lt;/p&gt;

&lt;h4 id=&quot;assume-1&quot;&gt;（5） 重新提出假设 Assume&lt;/h4&gt;

&lt;p&gt;既然不是图片的问题，那么会不会是其他事情上耗费了CPU呢。比如布局样式的计算。那么重新假设是局部样式的问题。在执行（2）过程。&lt;/p&gt;

&lt;p&gt;所谓实验，即是大胆假设，小心取证，如此往复，以求终解。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;监控&lt;/h2&gt;

&lt;p&gt;上面只是进行了一些方法论的探讨。但是有一件事情，是若要优化一定要做的。那就是“监控”。&lt;/p&gt;

&lt;p&gt;监控是个非常重要的东西。&lt;/p&gt;

&lt;p&gt;监控是个非常重要的东西。&lt;/p&gt;

&lt;p&gt;监控是个非常重要的东西。&lt;/p&gt;

&lt;p&gt;重要的事情说三遍。尤其是对于运行在生产环境的程序。这就像是一个体检，你得实时掌控程序的运行情况，知道问题出在了哪里，甚至有些时候知道：哎呀，出问题了。没有监控，程序一旦上线之后，就像脱缰的野马，跑到哪里，做了什么，你就是一头忙然了。突然有一天，老板说有人反馈咱们的app经常崩溃，当你没有crash监控，这个你都不知道从哪里查起。&lt;/p&gt;

&lt;p&gt;而且，监控也是优化的数据来源。他能够通过数据的指标来非常直观的告诉你，程序哪里有问题，你优化之后，效果是怎样的。现在网上有很多这方面的服务提供出来，比如bugly之类的，甚至有些是APM（application performance manager)，直接监控到程序的运行状态和性能。google一下，能搜出不少来。可以酌情，应用在自己开发的app中。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;说了半天，总结一下。优化是在可控的范围内有目的性的对现有程序的修改。一般可以使用逻辑分析法和实验法来定位、分析、描述问题。或者定性或者定量。无论哪种，要想优化，你得先建立起对自己app运行的监控体系。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号 &lt;strong&gt;iOS开发知识&lt;/strong&gt;：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>什么时候该使用枚举类型</title>
        <link>http://dzpqzb.com/2015/11/12/emun-usage-when-and-how.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/12/emun-usage-when-and-how.html</guid>
        <pubDate>Thu, 12 Nov 2015 16:34:02 +0800</pubDate>
        <description>&lt;p&gt;&lt;strong&gt;在值可穷尽的情况下可使用枚举类型&lt;/strong&gt;
当场景能够全覆盖的时候才使用枚举类型，比如付款状态：付款前，付款中，付款后，中前后三个状态能够覆盖所有付款的时间场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;值在不可穷尽的情况下不适合使用枚举。请考虑其他方式或者设计模式来解决当前问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而付款失败的种类，则不适合使用枚举类型，因为枚举无法覆盖全量的失败场景，在1.0版本的时候可能只有2，3，5这几种失败code，到了2.0的时候又多了6，8，9，。。。。如此类推，你会面临着不停的往这个枚举中添加新的值的窘境。而且在处理这个枚举的switch-case语句也会不断的膨胀，带来维护灾难。&lt;/p&gt;

&lt;p&gt;而我们在使用枚举的时候，通常会伴随着switch-case这种变形的if语句，通常当一个if语句嵌套超过3层的时候，就考虑一下这里是否存在问题了。于是我们我们使用枚举加switch-case来判断场景的情况。也是值得商榷的。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>OC中使用defer操作</title>
        <link>http://dzpqzb.com/2015/11/11/defer-ios-caozuo.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/defer-ios-caozuo.html</guid>
        <pubDate>Wed, 11 Nov 2015 21:32:15 +0800</pubDate>
        <description>&lt;p&gt;类似于 golang的defer  将一个操作延迟到作用域结束的时候 执行：常见于 关闭文件等。。。。这是异常处理的一种替代方案。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define DEFER(block) __unused OCDefer* defer___ = [[OCDefer alloc] initWithBlock:block];

typedef void(^OCDeferBlock)(void);

@interface OCDefer : NSObject

- (instancetype) initWithBlock:(OCDeferBlock)block;

@end

@interface OCDefer ()

{

    OCDeferBlock _block;

}

@end

@implementation OCDefer

- (instancetype) initWithBlock:(OCDeferBlock)block

{

    self = [super init];

    if (!self) {

        return self;

    }


    _block = block;

    return self;

}

- (void) dealloc

{

    if (_block) {

        _block();

    }

    _block = nil;

}

@end

//测试的例子

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions

{


    FILE* file = fopen(&quot;/afile.txt&quot;, &quot;r&quot;);

    DEFER(^{

        NSLog(@&quot;hello&quot;);

        fclose(file);

    });


    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

    // Override point for customization after application launch.

    self.window.backgroundColor = [UIColor whiteColor];

    [self.window makeKeyAndVisible];

    return YES;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>使用宏来减少代码重复</title>
        <link>http://dzpqzb.com/2015/11/11/macro-defines.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/macro-defines.html</guid>
        <pubDate>Wed, 11 Nov 2015 21:14:06 +0800</pubDate>
        <description>&lt;p&gt;使用宏定义来简化输入，提高输入的效率。同时提高输入准确性。&lt;/p&gt;

&lt;p&gt;案例一 属性定义 @property&lt;/p&gt;

&lt;p&gt;我们在定义一个类的属性的时候，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface TestObject : NSObject

@property (strong, nonatomic) NSString* title;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最起码要输入5个单词，四个符号和多个空格。写多了就会觉得这里重复输入的地方太多，为什么不想个办法优化一下输入呢。而且有些时候，中间的某个单词比如strong拼错了，还得会过头来继续修改。 优化输入效率，有很多种方式。比如使用sinepts。而且xcode的snip支持也不错。直接拖拽代码块就能够生成snip。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\\key is

\\@propertystrongnonatomic

@property (strong, nonatomic) &amp;lt;#type#&amp;gt;* &amp;lt;#name#&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的确是可以，但是你需要定义大量的snip来适应不同的定义peroperty的情况。那有没有更简单的一点的方法呢。必须有啊，使用宏啊。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define DEFINE_PROPERTY(mnmKind, type , name)       @property (nonatomic, mnmKind)  type  name

#define DEFINE_PROPERTY_ASSIGN(type, name)          DEFINE_PROPERTY(assign, type, name)

#define DEFINE_PROPERTY_ASSIGN_Double(name) DEFINE_PROPERTY_ASSIGN(double, name)

#define DEFINE_PROPERTY_STRONG(type, name) DEFINE_PROPERTY(strong, type, name)

#define DEFINE_PROPERTY_STRONG_NSString(name) DEFINE_PROPERTY_STRONG(NSString*, name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体参见DZProgrameDefines 我们完全可以通过使用宏定义，来扩展出一些列的定义属性的宏方法，借助于XCode的强大的自动补全来方便我们输入，少敲了非常多的字符。并且还减少了出错的情况，在可读性上，如果宏定义的名字起得好，可读性也不错。&lt;/p&gt;

&lt;p&gt;同时，不得不说的一点是我们借助于这种宏定义的方式，还规范和统一了定义属性的格式，方便维护同一个工程的多个同事修改同一份代码。让他们的代码质量能够保持在一个比较整齐的水平。 这种&lt;/p&gt;

&lt;p&gt;代码模板&lt;/p&gt;

&lt;p&gt;某些情况下，我们可能会写一些大量的重复代码，而这些代码又很难将其抽离出来做成一个独立的函数（甚至是lambda表达式），而这种时候宏的作用就体现出来了。考虑下述情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString* a = infos[@&quot;aKey&quot;];

if(!a) {

    [self postError:@&quot;need aKey&quot;];

    return;

}

NSString* b = infos[@&quot;bKey&quot;];

if(!b) {

    [self postError:@&quot;need bKey&quot;];

    return;

}

....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码中，我们需要从字典infos中取一批参数并且要判断这些参数是否为空，为空的时候报错并返回。其中有大量的代码是重复的。而这种重复又不太适合抽离成函数那么这个时候就可以这样做了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define GetValueWithLocalNameAndKey(name , key) \

\

NSString* name = [infos getWBValueForKey:key error:&amp;amp;error];\

if (!error) { [self postPayError:error]; return;}\

\

...

GetValueWithLocalNameAndKey(a,aKey);

GetValueWithLocalNameAndKey(b,bKey);

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做的时候，就将一段代码抽离成了模板。方便了使用和维护。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>ARC的一些细节之NSError的使用</title>
        <link>http://dzpqzb.com/2015/11/11/arc-error.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/arc-error.html</guid>
        <pubDate>Wed, 11 Nov 2015 21:10:40 +0800</pubDate>
        <description>&lt;p&gt;首先看一下这段代码会输出一些什么：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSError* error;
NSError** errPtr = &amp;amp;error;
NSLog(@&quot;%x&quot;,errPtr);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你认为，能够输出error的地址的话，也是情有可原的。但是，实际情况是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exxcepvhjrj20fk00zt8r.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编译器直接报错，编译都不通过，也就谈不上运行输出结果了。为什么会这样呢？&lt;/p&gt;

&lt;p&gt;在ARC下每个变量都有一个所有权修饰符默认是__strong，而在定义OC对象的指针变量的时候，需要注意其所有权修饰符需要与其所指向的对象的所有权修饰符保持一致。于是上面的代码需要改成这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    NSError* error;
    NSError* __strong * errPtr = &amp;amp;error;
    NSLog(@&quot;%x&quot;,errPtr);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到这你也许会问，经常遇到到使用NSError来返回错误信息的函数，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)verifyPassword:(NSString *)inPassword error:(NSError **)outError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么调用他的时候没有报错呢？&lt;/p&gt;

&lt;p&gt;因为在函数使用的时候，会默认的将outError的所有权变成__autoreleasing.并且在调用函数之前编译器回补齐一个临时变量，从而达到了所有权修饰符保持一致的效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)verifyPassword:(NSString *)inPassword error:(NSError *__autoreleasing*)outError {
    ....
}
....
{
    NSError __strong* error;
    NSError __autoreleasing* tmp = error;
    [anObject verifyPassword:@&quot;a&quot; error:&amp;amp;tmp];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个问题，在使用NSError或者使用指针在ARC下进行数据传递的时候，需要注意和小心。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>MAC下面提高工作效率的一些非常好用的工具</title>
        <link>http://dzpqzb.com/2015/11/11/tools-for-program.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/tools-for-program.html</guid>
        <pubDate>Wed, 11 Nov 2015 21:05:51 +0800</pubDate>
        <description>&lt;p&gt;编程相关：&lt;/p&gt;

&lt;p&gt;xcode（oc的神奇，ios编程必备，并且支持多种语言，写c++/c什么的都可以）&lt;/p&gt;

&lt;p&gt;Code2 （界面简单，写网页，js可以考虑）&lt;/p&gt;

&lt;p&gt;Prototyper（原型设计软件，可以说是现在原型设计软件中真对移动端开发优化的最好的，最强大的是他能设计动画，让原型不再只是一张张页面。）&lt;/p&gt;

&lt;p&gt;MesaSQLite（查看SQLite文件的利器，调试sqlite时必备）&lt;/p&gt;

&lt;p&gt;Sketch（现在都到3了，比PS轻巧方便，对于我这样没有美术功底的人来说，都能用它来给ios抠图了，哈哈）&lt;/p&gt;

&lt;p&gt;编辑器和排版：&lt;/p&gt;

&lt;p&gt;Sublim Text2/3 (在textmate好长时间不更新之后，mac上目前最好的编辑器，经过扩展后，可编程一个IDE。其插件机制让他无所不能，什么VIM模式了，语法高亮了，，，，都OK)&lt;/p&gt;

&lt;p&gt;Atom（Github推出的基于浏览器建构的编辑器，简单试用了一下，和Sublim的感觉差不多，但是在很多细节处理上优于Sublim，只是现在还在开发中，非常期待其完成版）&lt;/p&gt;

&lt;p&gt;Latex+Textmake+lyx(所想即所得的排版工具，尤其是写数学公式极其漂亮，缺点是入门门槛有点高，但是一旦学会绝对可以伪装自己成文艺青年。大神Knuth出品，没有更好只有最好)&lt;/p&gt;

&lt;p&gt;Markdown+Mou（简单的编辑和排版工具，一般情况下的任务都可以胜任，而且学习门槛低，非常易用。那个，自从用了markdown好久没有用latex了。）&lt;/p&gt;

&lt;p&gt;OmmWriter（文艺青年必备，让打字成为一种享受）&lt;/p&gt;

&lt;p&gt;Google Docs 大家一起编辑同一个文档&lt;/p&gt;

&lt;p&gt;版本控制：&lt;/p&gt;

&lt;p&gt;SourceTree（Git版本控制工具，简单易用，功能强大，基本上是Mac最好的了git软件了）&lt;/p&gt;

&lt;p&gt;Cornerstone（SVN版本控制工具，一样强大）&lt;/p&gt;

&lt;p&gt;Cocoapods（ios/Mac编程中，第三方库管理，比git的submodule和svn的外部链接方便多了，ios程序员必备）&lt;/p&gt;

&lt;p&gt;脚本语言:&lt;/p&gt;

&lt;p&gt;apple script（做一些简单的自动化的时候可以使用，语法极度简单，基本和说英语没区别，上手难度比bash和python等小多了，简单了解之后，即可使用。而且很多apple程序都支持apple script调用）&lt;/p&gt;

&lt;p&gt;文档查看：&lt;/p&gt;

&lt;p&gt;Dash（mac上最好的文档查看工具，没有之一。可以通过插件嵌入到xcode，vim。。。等其他软件中，一键唤起查询。结合Alfred使用，效果更佳）&lt;/p&gt;

&lt;p&gt;终端软件：&lt;/p&gt;

&lt;p&gt;iTerm2（非常好用的终端软件，主题可以美化，直接选择字符串就能够复制。。。。）&lt;/p&gt;

&lt;p&gt;tmux（高频率使用终端的人都有一个痛，不同任务需要打开不同的窗口，往往整个屏幕上层层叠叠的铺满了串口，搞过linux的人可能知道有个awosome的平铺式窗口管理器，在一个屏幕中平铺的展示多个窗口，极大限度的利用屏幕空间，显示更多的内容，而tmux这个软件就实现了在终端中的平铺式窗口管理，简单易用，可扩展性强。）&lt;/p&gt;

&lt;p&gt;vim（大家都懂得，神器）&lt;/p&gt;

&lt;p&gt;任务管理和笔记软件：&lt;/p&gt;

&lt;p&gt;WunderList（苹果某年的最佳软件，跨平台，简单易用，界面很漂亮。简单的任务管理。）&lt;/p&gt;

&lt;p&gt;Evernote （跨平台，知识积累和管理非常好的工具）&lt;/p&gt;

&lt;p&gt;Xmind（在思维脑图领域无论哪个平台这个是最好的了吧）&lt;/p&gt;

&lt;p&gt;ReadKit（自从google reader关了之后，订阅rss看资料就全靠它了。支持各种源，简单而不失强大）&lt;/p&gt;

&lt;p&gt;系统相关：&lt;/p&gt;

&lt;p&gt;Alfred V2（替代苹果自带的spotlight，全局搜索各种东西，只有你想不到没有你搜不到，PM2.5都能搜，里面的Workflow可以用来扩展神奇的功能，只能说你用了才会知道他的好。貌似新版的MAC QQ中也集成了类似的功能，只能说既生瑜何生亮了。）&lt;/p&gt;

&lt;p&gt;ParallelDesktop(用了之后我才知道什么叫做虚拟机，奥，不对应该是硬件共享。体验流畅，使用简单。可以将Windows、linux和Mac桌面完美的无缝粘合。顺便一说，你要想在Mac上完windows游戏的话，必备)&lt;/p&gt;

&lt;p&gt;1Password（这个每个网站都要密码的年代的救世主，只需要记住一个密码，其他的密码他帮你记住。密码管理界的老大哥。）&lt;/p&gt;

&lt;p&gt;f.lux（一个小工具根据当前时间和你的位置调整屏幕色温的，保护眼睛用的，程序猿的贴心保姆）&lt;/p&gt;

&lt;p&gt;Time Out （时间提醒工具，比如半个小时告诉你一次该起来运动一下了）&lt;/p&gt;

&lt;p&gt;CleanMyMac（系统清理工具，我在128G硬盘的情况下，能够正常运行系统和编程，全指望他帮助我删除无用文件了）&lt;/p&gt;

&lt;p&gt;Chrome（浏览器，个人感觉比safari好用）&lt;/p&gt;

&lt;p&gt;干坏事必备：&lt;/p&gt;

&lt;p&gt;File Viewer（二进制文件查看，分支别人的程序和数据）&lt;/p&gt;

&lt;p&gt;iExplorer（本来是ios设备管理工具，但是能够从设备中导出别人的程序，导出之后的事情，就自己想象了）
其他：事情MAC OS很多系统自带的应用都非常好用，日历，邮件什么的能用原生的尽量用原生的。能买个正版就买个正版吧，大家改BUG都挺不容易的。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>解决Instruments无法找到调试符号表的问题</title>
        <link>http://dzpqzb.com/2015/11/11/instruments-symbols-problem.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/instruments-symbols-problem.html</guid>
        <pubDate>Wed, 11 Nov 2015 20:30:53 +0800</pubDate>
        <description>&lt;p&gt;在使用Instruments中的time profile调试QQMSF的时候，发现原先有的可以定位到具体函数的功能怎么也掉不出来。Instruments只能定位到一个函数地址，没有具体的函数名。分析应该是调试符号表没有找到的问题。于是去工程设置里面找关于这个选项。有几个地方需要注意：&lt;/p&gt;

&lt;h2 id=&quot;debug-information-format&quot;&gt;1 Debug information format&lt;/h2&gt;
&lt;p&gt;这里原先的设置是DWARF，什么是DWARF，他与熟悉的dSYM文件什么关系？查了一下。
“DWARF与dSYM的关系是，DWARF是文件格式，而dSYM往往指一个单独的文件。在Xcode中如果不做特殊制定，debug information是被保存在executable文件中，可以使用dsymutil从executable中提取dSYM文件。”&lt;/p&gt;

&lt;p&gt;将选项调整为，DWARF with dSYM File，再次使用Instruments来profile发现能够定位的具体的函数名。改问题解决。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exxbpoejnhj20fk057wep.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分析可能是Instruments工具回去读取调试目标匹配的dsym文件，而当输出调试信息格式使用dwarf时，调试信息输出在了执行文件中，没有输出到dsym文件中，导致Instruments工具无法读取dsym文件，找不到符号表，结果就是无法定位函数名了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2、编译优化选项&lt;/h2&gt;
&lt;p&gt;在调试的时候尽量，保持零优化的模式，这样能够保证符号表的完整性。关于具体调试选项的描述可以参考gcc的文档。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/7df22103jw1exxbqjncmrj20fk0b3aaq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZPullDownViewController</title>
        <link>http://dzpqzb.com/2015/11/11/dzpulldownviewcontroller.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzpulldownviewcontroller.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:46:08 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzpulldownviewcontrollerhttpsgithubcomyishuiliuniandzpulldownviewcontroller&quot;&gt;&lt;a href=&quot;https://github.com/yishuiliunian/DZPullDownViewController&quot;&gt;DZPullDownViewController&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;两层结构的视图控制器，下拉的时候，上层的视图滑动，显示出下层的视图。如果上层视图控制器的rootView是UIScrollView或其子类（比如UITableView），在滑到头的时候，继续往下拉，会显示出下面的视图。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZCDNFiles</title>
        <link>http://dzpqzb.com/2015/11/11/dzcdnfiles.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzcdnfiles.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:45:04 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzcdnfiles&quot;&gt;DZCDNFiles&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/DZCDNFiles&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/DZCDNFiles.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCDNFiles&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/DZCDNFiles.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCDNFiles&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/DZCDNFiles.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCDNFiles&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/DZCDNFiles.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从CDN拉取静态文件的库&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;DZCDNFiles is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod &quot;DZCDNFiles&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;DZCDNFiles is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>MSHttpRPC</title>
        <link>http://dzpqzb.com/2015/11/11/mshttprpc.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/mshttprpc.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:43:55 +0800</pubDate>
        <description>&lt;h1 id=&quot;mshttprpc&quot;&gt;MSHttpRPC&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/MSHttpRPC&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/MSHttpRPC.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSHttpRPC&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/MSHttpRPC.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSHttpRPC&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/MSHttpRPC.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSHttpRPC&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/MSHttpRPC.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;
#介绍
MSHttpRPC是一个简单基于Http的RPC框架,完成了主体的HTTP-RPC的CS交互的工作，用户可通过注册相应的关键性的Block来完成自定义的功能。已经完成了初步的RPC交互框架。
## Usage&lt;/p&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;MSHttpRPC is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
pod &quot;MSHttpRPC&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;MSHttpRPC is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>MSInputScrollViewController</title>
        <link>http://dzpqzb.com/2015/11/11/msinputscrollviewcontroller.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/msinputscrollviewcontroller.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:42:20 +0800</pubDate>
        <description>&lt;h1 id=&quot;msinputscrollviewcontroller&quot;&gt;MSInputScrollViewController&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/MSInputScrollViewController&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/MSInputScrollViewController.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSInputScrollViewController&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/MSInputScrollViewController.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSInputScrollViewController&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/MSInputScrollViewController.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSInputScrollViewController&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/MSInputScrollViewController.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;MSInputScrollViewController is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
pod &quot;MSInputScrollViewController&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;MSInputScrollViewController is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZCache</title>
        <link>http://dzpqzb.com/2015/11/11/dzcache.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzcache.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:41:41 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzcache&quot;&gt;DZCache&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/DZCache&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/DZCache.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCache&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/DZCache.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCache&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/DZCache.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCache&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/DZCache.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;DZCache is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod &quot;DZCache&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;DZCache is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZSinglonFactory</title>
        <link>http://dzpqzb.com/2015/11/11/dzsinglonfactory.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzsinglonfactory.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:40:39 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzsinglonfactory&quot;&gt;DZSinglonFactory&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/DZSinglonFactory&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/DZSinglonFactory.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZSinglonFactory&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/DZSinglonFactory.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZSinglonFactory&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/DZSinglonFactory.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZSinglonFactory&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/DZSinglonFactory.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;DZSinglonFactory is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod &quot;DZSinglonFactory&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;DZSinglonFactory is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZSilkKit</title>
        <link>http://dzpqzb.com/2015/11/11/dzsilkkit.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzsilkkit.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:40:06 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzsilkkit&quot;&gt;DZSilkKit&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/DZSilkKit&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/DZSilkKit.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/DZSilkKit&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/DZSilkKit.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/DZSilkKit&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/DZSilkKit.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/DZSilkKit&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/DZSilkKit.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;DZSilkKit is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
pod &quot;DZSilkKit&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;DZSilkKit is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZLayoutTable</title>
        <link>http://dzpqzb.com/2015/11/11/dzlayouttable.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzlayouttable.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:38:54 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzlayouttable&quot;&gt;DZLayoutTable&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/DZLayoutTable&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/DZLayoutTable.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/DZLayoutTable&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/DZLayoutTable.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/DZLayoutTable&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/DZLayoutTable.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/DZLayoutTable&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/DZLayoutTable.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;DZLayoutTable is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
pod &quot;DZLayoutTable&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;DZLayoutTable is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZGeometryTools</title>
        <link>http://dzpqzb.com/2015/11/11/dzgeometrytools.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzgeometrytools.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:37:22 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzgeometrytools&quot;&gt;DZGeometryTools&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/DZGeometryTools&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/DZGeometryTools.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZGeometryTools&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/DZGeometryTools.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZGeometryTools&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/DZGeometryTools.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZGeometryTools&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/DZGeometryTools.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;DZGeometryTools is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod &quot;DZGeometryTools&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;DZGeometryTools is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZAdjustFrame</title>
        <link>http://dzpqzb.com/2015/11/11/dzadjustframe.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzadjustframe.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:34:22 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzadjustframe&quot;&gt;DZAdjustFrame&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/DZAdjustFrame&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/DZAdjustFrame.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/DZAdjustFrame&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/DZAdjustFrame.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/DZAdjustFrame&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/DZAdjustFrame.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/DZAdjustFrame&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/DZAdjustFrame.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;DZAdjustFrame is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;pod &quot;DZAdjustFrame&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;DZAdjustFrame is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>ARC(甚至是代码行数)与安装包体积之间的关系</title>
        <link>http://dzpqzb.com/2015/11/11/arcmrccompare.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/arcmrccompare.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:23:40 +0800</pubDate>
        <description>&lt;p&gt;此文的目的就是通过一些列的逻辑推理来推测出ARC语安装包体积之间的关系，或者说ARC对于安装包体积的一些影响。&lt;/p&gt;

&lt;p&gt;两个事物之间的关系主要存在两种关系：相关性和因果性。相关性，表现为当一个事物发生改变的时候，另外一个事物同时也会跟着发生改变。而因果性则表现为，一个事物的变化会引起另外一个事物的变化。&lt;/p&gt;

&lt;p&gt;如果我们决定因为安装包体积而抛弃ARC的话，我们就必须非常明确的确定，ARC与安装包增大之间有因果性关系。即，使用ARC是安装包体积增长的一个原因。而非使用ARC与否和安装包体积之间呈现出相关性，而且。&lt;/p&gt;

&lt;p&gt;在《ARC对安装包影响的分析（高清、多图》一文中，使用“单因变量“试验，确定了使用非ARC之后，安装包体积有下降的趋势。这种方法，存在的缺陷是，事先已经假定了ARC与安装包体积之间是线性相关的关系，即通过一个简单的f(x)=kx，这样的一个公式就能够表示ARC与安装包体积之间的关系。然后，在这个假设之上去找支撑这个观点的依据。很幸运的找到了。但是，其前提假设正确与否没有给出详细的说明。&lt;/p&gt;

&lt;p&gt;但是实际情况是，ARC与安装包体积之间绝对不是简单的线性关系。而是非线性的。ARC通过不同的层面在影响着安装包体积大小。也就是说我们要确定ARC是怎样影响安装包体积的，才能去讨论ARC与安装包体积之间的关系。&lt;/p&gt;

&lt;p&gt;在开篇我很明白的告诉读者，最后不会得出一个类似于f(x)=kx的公式来，不会有20行ARC对应1KB的结论。因为在以下阐述的ARC对于安装包体积的影响中，有很多因素是非线性且不可量化的。在手Q或者任何一个软件，这样一个复杂性系统中，很多原始的简单的基于线性可量化的理论已经显得捉襟见肘。我们应当无奈的而且坦诚的承认，在很多复杂性系统中，或者根本就没有微观规律可言。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;直接影响，直接作用于安装包体积&lt;/h2&gt;

&lt;p&gt;所谓直接影响就是代码是否使用ARC和安装包内二进制可执行文件间的具有直接关系（前提是代码行数与二进制文件大小存在直接关系）。首先我们先假定，上述结论成立。我们再来分析。&lt;/p&gt;

&lt;h3 id=&quot;arcmrc&quot;&gt;ARC与MRC之间指令差异&lt;/h3&gt;

&lt;p&gt;参考Clang 3.5 documentation OBJECTIVE-C AUTOMATIC REFERENCE COUNTING (ARC)。我们了解到，Clang实现ARC的主要方式就是将内存管理转变成对象关系处理，并通过在runtime中增加了一些列的函数来支持这些关系处理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id objc_autorelease(id value);
void objc_autoreleasePoolPop(void *pool);
void *objc_autoreleasePoolPush(void);
id objc_autoreleaseReturnValue(id value);
void objc_copyWeak(id *dest, id *src);
void objc_destroyWeak(id *object);
id objc_initWeak(id *object, id value);
id objc_loadWeak(id *object);
id objc_loadWeakRetained(id *object);
void objc_moveWeak(id *dest, id *src);
void objc_release(id value);
id objc_retain(id value);
id objc_retainAutorelease(id value);
id objc_retainAutoreleaseReturnValue(id value);
id objc_retainAutoreleasedReturnValue(id value);
id objc_retainBlock(id value);
id objc_storeStrong(id *object, id value);
id objc_storeWeak(id *object, id value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且，在很多处理内存的方式上并像很多网上流传的材料所说的那样——在编译器帮助开发者插入retain与release这么简单。虽然他们的基础性技术都是retain count。但是在具体处理上所使用的模型已经发生改变。所以参照MRC的二进制文件，查找ARC的二进制文件指令的增长数量，或者参照ARC的二进制文件去查找MRC减少的指令。就不太靠谱了，他们使用的指令都不一样。怎么去对比。&lt;/p&gt;

&lt;p&gt;线性拟合&lt;/p&gt;

&lt;p&gt;通过与手Q基础侧的人了解到得出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;20行ARC = 1kb
30行MRC = 1kb
100行C++ = 1KB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个结论时，采样的文件只有几个使用ARC更改过的文件。首先抛开结果是否正确不讲，第一采样空间的代表性值得怀疑，第二样本空间是否够大也是值得怀疑。有了怀疑于是就就用整个手Q中的.o文件的大小与代码行数之间进行多项式拟合。之所以采用.o文件是因为，直接测量当个文件对于安装包大小的影响非常困难。退而求其次，算单个文件与.o文件之间的关系。采样空间为手Q项目中的所有*.m文件。样本量约为1500+-。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os
from os.path import getsize, join
import numpy as np
import scipy as sp
from scipy.optimize import leastsq
import pylab as pl

m = 9

def fake_func(p, x):
    f = np.poly1d(p)
    return f(x)

def residuals(p, y, x):
    return y - fake_func(p, x)




class OCFile:
    def __init__(self, linescount, arc):
        self.linescount = linescount
        self.arc = arc

def get_all_file(floder_path):
    dic = {}
    if floder_path is None:
        raise Exception(&quot;floder_path is None&quot;)
    for dirpath, dirnames, filenames in os.walk(floder_path):
        if len(dirpath) &amp;gt;= 6:
            if dirpath[0:6] == &#39;./.svn&#39;:
                continue
        for name in filenames:
            p = dirpath + &#39;/&#39; + name
            if name[-2:] == &#39;.m&#39;:
                arc = 0
                if &quot;[super dealloc]&quot; in open(p).read():
                    arc = 0
                else:
                    arc = 1
                count = len(open(p,&#39;rU&#39;).readlines())
                tf = OCFile(count, arc)
                key = name[0:-2]+&quot;.o&quot;
                dic[key] = tf

    return dic

rclinesDic = get_all_file(&#39;/Users/stonedong/Documents/TencentWork/master&#39;)


arcf = open(&quot;arc.txt&quot;, &quot;w&quot;)
mrcf = open(&quot;mrc.txt&quot;, &quot;w&quot;)


arcx= []
arcy = []
mrcx = []
mrcy = []

for item in  os.listdir(&#39;.&#39;):
    if item[-2:] == &#39;.o&#39;:
        size = getsize(join(&quot;.&quot;, item))
        if item in rclinesDic.keys():
            of = rclinesDic[item]
            fp = mrcf
            if of.arc == 1:
                fp =arcf
                arcx.append(of.linescount)
                arcy.append(size/1024)
            else:
                fp = mrcf
                mrcx.append(of.linescount)
                mrcy.append(size)
            fp.write(item)
            fp.write(&#39;\t&#39;)
            fp.write(str(size))
            fp.write(&#39;\t&#39;)
            fp.write(str(of.linescount))
            fp.write(&quot;\n&quot;)

fp.close()



x_show = np.linspace(0, 3000, 1000)

p0 = np.random.randn(m)

plsq = leastsq(residuals, p0, args=(mrcy, mrcx))
print plsq[0]
print &quot;\n&quot;
pl.plot(x_show, fake_func(plsq[0], x_show), label=&#39;fitted curve&#39;)
pl.plot(mrcx, mrcy, &#39;bo&#39;, label=&#39;with noise&#39;)
pl.legend()
pl.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;拟合结果：&lt;/h3&gt;

&lt;h4 id=&quot;arc&quot;&gt;ARC&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/7df22103jw1exx9bd2n76j20fk0bomxq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拟合的多项式参数为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx9bupyuvj20ev02qjrw.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;mrc&quot;&gt;MRC&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx9ciiwjtj20fk0bo3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拟合的多项式参数为：
&lt;img src=&quot;http://ww1.sinaimg.cn/large/7df22103jw1exx9ctbty7j20e10283yz.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过上图很明显看出，使用线性的多现实拟合的时候，结果极度欠拟合。拟合出的特征多项式完全没有意义。从而更加直观的可以看出，ARC或者MRC对于安装包大小的影响绝非线性关系。并且通过上述结果页可以看出，找不出一个合理的多项式用来表征ARC与安装包体积的关系，也找不出一个多项式来表征MRC与安装包体积的关系。最直接的结论就是，代码行数与安装包体积之间的关系不是线性关系。宏观上看，的确代码行数增加安装包体积增加。但是两者之间不存在线性关系。&lt;/p&gt;

&lt;p&gt;因而所得出上述ARC或者MRC与安装包体积之间存在20行ARC对应1KB是存疑的。可能这是一个均值，但是均值在很多情况下是不具有普适性的。不能将使用均值来断定，我们实际在编程中代码行数对于安装包体积的影响。&lt;/p&gt;

&lt;p&gt;同时计算了其均值和方差：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx9d9gwbbj20b502j3yo.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在方差如此之大的情况下，均值的意义就非常小了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;间接影响，通过影响程序员来影响安装包体积的大小&lt;/h2&gt;

&lt;p&gt;通过上面的讨论，我们已经初步得出结论，ARC对于安装包体积的影响绝不是一个简单的线性关系。在手Q这样一个复杂系统当中，ARC甚至是代码行数，对于安装包体积的影响绝对不是简单粗暴的，不是可以使用一个函数表达式就能说明的。&lt;/p&gt;

&lt;p&gt;《技术的本质》一书中指出，技术通过影响人然后影响一切。同样的道理，ARC设计出来之后，首先影响的是我们的编程方式。而后通过我们编程方式的改变去影响其他，包括安装包体积的大小。&lt;/p&gt;

&lt;p&gt;比如block的使用方式，在定义变量的时候使用strong关键字。甚至是设计模式的设计方式都会发生改变。&lt;/p&gt;

&lt;p&gt;这些都是不可量化的影响。试问当这些因素加入到我们考量ARC与安装包体积之间的关系的时候，你如何去用数值度量这种影响？谁有能说清楚一个设计模式设计方式的改变对于安装包体积的影响有多大？&lt;/p&gt;

&lt;p&gt;还有即使同样的一个算法，不同的编程人员也会写出不一样的代码来，这又如何去度量？&lt;/p&gt;

&lt;p&gt;人是在整个软件过程中最不稳定的因素。前辈们常说，出问题的时候首先怀疑自己，然后去怀疑工具，甚至你都不需要怀疑工具。在我们没有解决好自己的问题之前，去怀疑工具，避免有点过了。&lt;/p&gt;

&lt;p&gt;纯粹个人见解的是：对于安装包体积影响最大的可能就是编程人员了把。如果能够减少逻辑冗余，能够尽可能的抽出公共组件，控制安装包体积大小不是没有可能的。&lt;/p&gt;

&lt;p&gt;同时，在上述的论述中，我们还没有牵扯到，文件之间的引用，函数之间的调用，类之间的交互等更复杂的关系。将之考量进去之后，ARC与安装包体积之间的关系将会更加错综复杂不可度量。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;结论&lt;/h2&gt;

&lt;p&gt;通过上述，直接影响的定量分析手段和间接影响的定性分析的手段，我们初步得出了代码行数与安装包体积大小不存在线性关系。ARC对于安装包体积的影响也不是线性关系。代码行数、ARC、MRC以一种复杂且不可度量的方式影响着安装包体积大小。我们只能说有一个宏观趋势：代码增多，安装包体积增大。但是是如何影响安装包体积增大了，这个真的说不清楚了。太复杂了。已不是20arc-&amp;gt;1kb这样简单。&lt;/p&gt;

&lt;p&gt;还有一点，ARC正在不断的变化之中，我们根据当前的ARC这种工具的的状态做出的判断，很可能只是因为Xcode和Clang的一次升级，就会变成谬误。语言和工具在发展，他们发展出了更多更好用的工具（包括ARC）在内，辅助我们控制整个软件过程中的复杂性。我们编程不止要实现产品的需求，同样也需要控制整个工程的复杂性，包括代码质量（可维护性和可阅读性等）、包括项目进度、包括安装包体积。。。。如果单纯因为一个简单的一个没有可靠理论依据的与安装包体积间线性相关性的现象就鲁莽的怀疑ARC，未免有点一叶障目不见泰山。&lt;/p&gt;

&lt;p&gt;当摩尔定律让机器的性能不断提升的时候，我们可能不像以前，机器资源紧缺的时候那么去关注优化机器的性能，优化CPU消耗，优化内存、优化IO、优化存储….这个时候，我们是否应该关注一下怎样去优化人的时间。优化我们苦逼的程序员那宝贵的时间。而ARC就是这么一个好东西能够优化，我们程序员的时间。强烈支持ARC。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注&lt;br /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>iOS设计模式反思之单例模式的进化</title>
        <link>http://dzpqzb.com/2015/11/11/danlimoshiios.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/danlimoshiios.html</guid>
        <pubDate>Wed, 11 Nov 2015 15:25:12 +0800</pubDate>
        <description>&lt;h1 id=&quot;section&quot;&gt;单例模式&lt;/h1&gt;

&lt;p&gt;什么是单例模式？ 单例模式想一个大独裁者，他规定在他的国度里面，所有数据的访问和请求都得经过他，甚至你要调用相关的函数也得经过它。学术一点就是，单例模式，为某一类需求和数据提供了统一的程序接口。主要的实现技术就是，确保全局只有一个对象的实例存在。举个例子把，比如NSNotificationCenter 中的 defaultCenter 负责全局的消息分发、NSFileManager 的 defaultManager 统一负责物理文件的管理、NSUserDefaults 的 standardUserDefaults 统一管理用户的配置文件……不一而足。在整个iOS框架中，可以说是大规模使用了单例模式。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;单例模式的原理及实现&lt;/h2&gt;

&lt;h3 id=&quot;arc&quot;&gt;在非ARC情况下实现一个单例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@implementation DZSinglonNoARC
+ (DZSinglonNoARC*) shareInstance
{
    static DZSinglonNoARC* share = nil;
    @synchronized(self)
    {
        if (!share) {
            share = [[super allocWithZone:NULL] init];
        }
    }
    return share;
}
+ (instancetype) allocWithZone:(struct _NSZone *)zone
{
    return [self shareInstance];
}
- (instancetype) copyWithZone:(NSZone*)zone
{
    return self;
}
- (id) retain
{
    return [DZSinglonNoARC shareInstance];
}
- (oneway void) release
{
 
}
- (instancetype) autorelease
{
    return self;
}
- (unsigned) retainCount
{
    return UINT_MAX;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先要初始化一个该类的静态化变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static DZSinglonNoARC* share = nil;
    @synchronized(self)
    {
        if (!share) {
            share = [[super allocWithZone:NULL] init];
        }
    }
    return share;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里进行了加锁处理，是为了防止多线程重入的情况下，造成静态变量多次分配内存和初始化，从而会导致数据混乱。这里加锁的对象是self，实际上是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[DZSinglonNoARC class]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类DZSinglonNoARC的class对象，也就是说加锁对象是全局唯一的一个Class对象。而且在这里share的定义放在了函数shareInstance之内，是要让share变成一个函数内的局部变量这样可以防止，外部的异常访问。看到网上有些教程中，把share的定义放在函数之外，变成了文件内的一个全局静态变量，这样会存在其他函数异常操作share的情况。&lt;/p&gt;

&lt;p&gt;注意在初始化share的时候我们使用的是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;share = [[super allocWithZone:NULL] init];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之所以这样做，是为了防止想用[DZSinglonNoARC alloc]等函数的时候，会与allocWithZone引起的死锁和死循环。&lt;/p&gt;

&lt;p&gt;而关于此处加锁的处理还有一个优化版本，在4.0以上的SDK有了闭包之后，我们可以这么做&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ (DZSinglonNoARC*) share2
{
    static DZSinglonNoARC* share = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;amp;onceToken, ^{    
        share = [[super allocWithZone:NULL] init];
    });    
    return share;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用dispatch_once体带原来的加锁操作，这样做的好处就是可以减少每次加锁的时间，优化了程序性能。dispatch_once函数接收一个dispatch_once_t用于检查该代码块是否已经被调度的谓词（是一个长整型，实际上作为BOOL使用）。它还接收一个希望在应用的生命周期内仅被调度一次的代码块，对于本例就用于share实例的实例化。dispatch_once不仅意味着代码仅会被运行一次，而且还是线程安全的。完全可以替代相对低效的加锁操作。&lt;/p&gt;

&lt;p&gt;然后是重载了一些列的函数，重载这些函数的目的，就是修改原有的NSOjbect的内存操作相关的函数，保持内存中有且只有一个该类的对象。&lt;/p&gt;

&lt;h3 id=&quot;arc-1&quot;&gt;arc下的实现&lt;/h3&gt;

&lt;p&gt;我们先看一个例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@implementation DZSinglonARC
+  (DZSinglonARC*) shareInstance
{
    static DZSinglonARC* share = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;amp;onceToken, ^{
        share = [[super allocWithZone:NULL] init];
    });
    return share;
}
+ (instancetype) allocWithZone:(struct _NSZone *)zone
{
    return [self shareInstance];
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上面的代码我们能够看出其实在ARC下单例的实现方式与非ARC下大同小异，只不过是没有重载内存管理的函数而已。而这也得益于ARC这种技术。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;单例工厂&lt;/h2&gt;

&lt;p&gt;在实际的编程工作中，随着项目规模的不断扩大，我们往往发现在整个项目中存在着大量的单例。于是我们就会遇到一个问题如何去管理这些单例。 同时，也会遇到每一次都要按照上面的实现方式从头来一遍来实现一个单例，从编程效率上看难免有些低下，毕竟很多代码都是相同的。使用设计模式的目标之一就是合理的干掉重复的代码。那么有没有一个好的方式来管理这些单例呢，我们很自然的想到了工厂模式。&lt;/p&gt;

&lt;p&gt;工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。” 创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。(引用自WIKI)&lt;/p&gt;

&lt;p&gt;工厂模式解决的就是这种，重建同类型对象的问题。而这里，我们可以把单例看成同类型的一系列对象。那就创建一个单例工厂吧。 项目地址：https://github.com/yishuiliunian/DZSinglonFactory.git&lt;/p&gt;

&lt;p&gt;先看一下如何实现一个简单的单例工厂&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface DZSingletonFactory()
{
    NSMutableDictionary* data;
}
@end
@implementation DZSingletonFactory
- (id) init
{
    self = [super init];
    if (self) {
        data = [[NSMutableDictionary alloc] init];
    }
    return self;
}
+ (DZSingletonFactory*) shareFactory
{
    static DZSingletonFactory* share = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;amp;onceToken, ^{
        share = [[DZSingletonFactory alloc] init];
    });
    return share;
}
- (id) copyWithZone:(NSZone*)zone
{
    return self;
}
//over singlong
- (void) setShareData:(id)shareData  forKey:(NSString*)key
{
        if (shareData == nil) {
            return;
        }
        [data setObject:shareData forKey:key];
}
- (id) shareDataForKey:(NSString*)key
{
        return [data objectForKey:key];
}
- (id) shareInstanceFor:(Class)aclass
{
    NSString* className = [NSString stringWithFormat:@&quot;%@&quot;,aclass];
     @synchronized(className)
    {
        id shareData = [self shareDataForKey:className];
        if (shareData == nil) {
            shareData = [[NSClassFromString(className) alloc] init];
            [self setShareData:shareData forKey:className];
        }
        return shareData;
    }
 
}
- (id) shareInstanceFor:(Class)aclass category:(NSString *)key
{
    NSString* className = [NSString stringWithFormat:@&quot;%@&quot;,aclass];
    NSString* classKey = [NSString stringWithFormat:@&quot;%@-%@&quot;,aclass,key];
    @synchronized(classKey)
    {
        id shareData = [self shareDataForKey:classKey];
        if (shareData == nil) {
            shareData = [[NSClassFromString(className) alloc] init];
            [self setShareData:shareData forKey:classKey];
        }
        return shareData;
    }
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实单例工厂类也是一个实例，之所以这么做，是因为我们所生产的单例总得有个仓库存着吧。而这个单例工厂类除了有生产单例的功能，也担负着仓库存储生产的单例的功能。私有变量NSMutableDictionary* data;就是仓库。&lt;/p&gt;

&lt;p&gt;而生产的车间是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (id) shareInstanceFor:(Class)aclass
{
    NSString* className = [NSString stringWithFormat:@&quot;%@&quot;,aclass];
     @synchronized(className)
    {
        id shareData = [self shareDataForKey:className];
        if (shareData == nil) {
            shareData = [[NSClassFromString(className) alloc] init];
            [self setShareData:shareData forKey:className];
        }
        return shareData;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数及其简单，我们使用了Objective-C一些动态语言的特性，直接通过类Class对象来生成实例，如果你对objc的底层有些了解的话，应该知道其实Class也是一个对象，他也能够执行objc的方法。也就是说，如果我们要生成类A的一个实例，只要我们有了类A的类型对象（Class）实例就OK，然后通过[(Class*)aClass new]你就能轻而易举的生成一个实例。&lt;/p&gt;

&lt;p&gt;在我们通过这种技术生成了一个单例的实例之后，将其存储在仓库data里面，下次再次请求这个类的实例的时候，只要从仓库中取出来用就行了。&lt;/p&gt;

&lt;p&gt;我们甚至为了编程时再少写点代码可以写一个函数和宏：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id  DZSingleForClass(Class a)
{
    return [DZShareSingleFactory shareInstanceFor:a];
}
..........
#define DZShareSingleFactory [DZSingletonFactory shareFactory]
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
    id  DZSingleForClass(Class a);
#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们在需要创建单例的时候一句话就能搞定：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ (DZSingletonFactory*) shareInstance
{
    return DZSingleForClass([DZShareSingleFactory class]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过这只是一个极度简化版的单例工厂，很多保护性的措施还都没做。比如对于allocWithZone的重载等，还有一些单例注销的操作。&lt;/p&gt;

&lt;p&gt;其实这是一种这种的策略，我们没有重载内存管理函数，是为了能够在后面为了节省内存，在单例较长时间不用的时候将其销毁掉，等下次用的时候再创建。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void) destoryInstanceFor:(Class)aclass
{
    NSString* className = [NSString stringWithFormat:@&quot;%@&quot;,aclass];
    @synchronized(className) {
        if ([self shareDataForKey:className]) {
            [data removeObjectForKey:className];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然这中使用方式，看起来不太像是严格意义上的单例模式，但是他却完成单例模式最根本的意图，把接口和功能统一。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;模块管理系统&lt;/h2&gt;

&lt;p&gt;还记得文章的标题吗？单例模式的进化，那么这里单例模式要进化到什么地步呢？在实际的编码过程中，随着工程规模的不断扩大，我们可能会在我们的项目中大规模的时候单例模式。就像是世界中，有了N多个独裁者，协调这些独裁者，对任何一个系统来说都是困难的。这个时候，就会遇到一个问题：如何有效的管理数量较多的单例。虽然我们使用单例工厂的方式，解决了单例统一构建的问题，但是没有能够解决统一管理的问题。这里统一管理的问题包括：&lt;/p&gt;

&lt;p&gt;单例初始化的控制，不同的单例在初始化的时候可能需要不同的参数。甚至有些单例可以延迟加载。
单例注销的统一管理。
能够让开发者或者SDK使用者，直接了当的看到整个工程中使用了多少单例，每个单例的大概模样是怎么样子的。
管理各个单例之间的依赖关系。比如地理位置信息单例可能会依赖数据库的一个单例。
根据不同的需求，动态的加载某些单例。
其他等等……
这些需求一列，你会感觉怎么像是在说一个包管理系统比如debian的apt-get或者node的npm之类的东西呢，甚至还有点像windows的动态链接库或者linux的模块化机制。&lt;/p&gt;

&lt;p&gt;其实如果我们剖析一下的话，其实单例模式是一种实现程序架构模块化的有利工具。他将某些内聚性非常高的功能，聚合在其一起，通过单一实例与外界交互。同时也降低了与其他单例之间的耦合性。从宏观的角度来看，我们可以把一个个单例看成一个个功能性模块，用一个形象的比喻就是插件。这样，一个充斥着大量单例，并且能够对这些单例有效管理的系统，从宏观的角度看，就像是一个插件系统（准确说是模块管理系统）。&lt;/p&gt;

&lt;p&gt;而上面提到的项目&lt;a href=&quot;https://github.com/yishuiliunian/DZSinglonFactory.git&quot;&gt;DZSinglonFactory&lt;/a&gt;只是这个插件系统开了个头。有兴趣的可以一起来玩上一个iOS上的简单的插件管理系统。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>通过实现一个TableView来理解iOS UI编程</title>
        <link>http://dzpqzb.com/2015/11/11/tongguoshixiantableview.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/tongguoshixiantableview.html</guid>
        <pubDate>Wed, 11 Nov 2015 14:59:31 +0800</pubDate>
        <description>&lt;p&gt;通过实现一个TableView来理解iOS UI编程&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;阅读&lt;/h2&gt;
&lt;p&gt;本书可以通过GitBook阅读，请移步：&lt;a href=&quot;https://www.gitbook.com/book/yishuiliunian/implementate-tableview-to-understand-ios/details&quot;&gt;通过实现TableView来理解IOS编程&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;查看源码&lt;/h2&gt;
&lt;p&gt;源码请查看&lt;a href=&quot;https://github.com/yishuiliunian/DZTableView&quot;&gt;GitHUb&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;欢迎关注iOS开发公共账号iOS_Tips：扫描下方二维码关注
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exx11uhhkoj20by0by3zc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>