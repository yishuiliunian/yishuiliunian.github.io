<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>一水的技术博客</title>
    <link>http://dzpqzb.com</link>
    <description>iOS开发者，讲述一些关于OC、iOS、设计模式和架构的故事。欢迎关注微信公共账号IOS_Tips</description>
    
      <item>
        <title>Objective-C中正确的判断父类是否实现了某个方法</title>
        <link>http://dzpqzb.com/2016/08/15/super-class-response-to-selector.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2016/08/15/super-class-response-to-selector.html</guid>
        <pubDate>Mon, 15 Aug 2016 18:13:01 +0800</pubDate>
        <description>&lt;h1 id=&quot;objective-c&quot;&gt;Objective-C中正确的判断父类是否实现了某个方法&lt;/h1&gt;

&lt;p&gt;在某些特殊的场景下，我们会有判断父类是否实现了某个方法的需求。比如在tableViewDelegate中的didSelectCellAtIndexPath方法中：为了不覆盖父类的对应方法，在实现的时候需要实现判断一下父类是否实现了该方法，实现了则调用一下父类的方法，没有实现则不调用如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
- (void) tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    Class supClass = class_getSuperclass([self class]);
    NSLog(@&quot;self class is %@, super class is %@&quot;,self.class, supClass);
    if (class_respondsToSelector(supClass, _cmd)) {
        struct objc_super sup = {
            .receiver = self,
            .super_class = [self class]
        };
        void(*func)(struct objc_super*,SEL,UITableView*,NSIndexPath*) = (void*)&amp;amp;objc_msgSendSuper;
        func(&amp;amp;sup, _cmd,tableView, indexPath);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But，这样做会造成死循环。为什么呢，且看下面的这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface A : AnSuper

@end
@implementation A

- (void) test
{
    Class supClass = class_getSuperclass([self class]);
    NSLog(@&quot;self class is %@, super class is %@&quot;,self.class, supClass);
    if (class_respondsToSelector(supClass, _cmd)) {
        struct objc_super sup = {
            .receiver = self,
            .super_class = [self class]
        };
        void(*func)(struct objc_super*,SEL) = (void*)&amp;amp;objc_msgSendSuper;
        func(&amp;amp;sup, _cmd);
    }
}
@end

@interface B  : A
@end

@implementation B
@end

@interface C : B
@end

@implementation C
@end

void TestC() {
    C* c = [C new];
    [c test];
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C类继承自B类，B类继承自A类，在A中有方法test，在test方法中判断了其父类是否实现过test方法，实现则行执行。当创建一个C的实例调用test方法的时候。结果就死循环到这个test方法了。&lt;/p&gt;

&lt;p&gt;因为当调用[self class]的时候，无论当前方法实现在哪个类中，其都是以当前的instance的isa指针为准的，也就是说当C类的Instance上调用class方法的时候，返回的都是当前的类C，而去查找其父类则会一直是B类。不会像我们想想的一样，是从类A开始查找，找到A类的父类AnSuper。&lt;/p&gt;

&lt;p&gt;而在test方法中，判断父类是否实现了test方法，则一直是在判断B类是否实现了test方法，返回YES，一直在调用。死循环了就。&lt;/p&gt;

&lt;p&gt;而我们的目标是为了判断当前的方法是否在父类中有实现，很明显因为[self class]无法返回这个方法实现所在的类。导致无法满足的需求，还产生了BUG。本质上使用[self class]这个方法就是不对的。那应该使用什么呢？&lt;/p&gt;

&lt;p&gt;在C++中有__CLASS__的环境变量，来指称当前的类。而OC中没有类似的环境变量,可以参见Apple Mailing List中的讨论&lt;a href=&quot;http://lists.apple.com/archives/objc-language/2008/Aug/msg00177.html&quot;&gt;__CLASS__macro for current Obj-C class name?&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要是有个__CLASS__能够指称当前的方法实现所在的类就好了，我们的需求就能迎刃而解。然后就去环境变量中挨个查找。终于发现了__FOUNCTION__。这个东西。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-[A test]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在A类的test方法中打印一下，能够看到其输出了当前的函数实现所在的位置。也就是说我们可以从中提取出，当前方法实现所在的类。哈哈。说干就干。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Class DZGetCurrentClassInvocationSEL(NSString* functionString)
{
    
    if (functionString.length == 0) {
        return nil;
    }
    
    NSRange rangeStart = [functionString rangeOfString:@&quot;[&quot;];
    NSRange rangeEnd = [functionString rangeOfString:@&quot; &quot;];
    if (rangeStart.location == NSNotFound || rangeEnd.location == NSNotFound) {
        return nil;
    }
    NSInteger start = rangeStart.location + rangeStart.length;
    if (rangeEnd.location - start &amp;lt;= 0) {
        return nil;
    }
    NSRange classRange = NSMakeRange(start, rangeEnd.location - start);
    NSString *classString = [functionString substringWithRange:classRange];
    return NSClassFromString(classString);
}

BOOL DZCheckSuperResponseToSelector(Class cla, SEL selector) {
    Class superClass = class_getSuperclass(cla);
    return class_respondsToSelector(superClass, selector);
}



FOUNDATION_EXTERN Class DZGetCurrentClassInvocationSEL(NSString*  functionString);

FOUNDATION_EXTERN BOOL DZCheckSuperResponseToSelector(Class cla, SEL selector);

#define __IMP_CLASS__  DZGetCurrentClassInvocationSEL([NSString stringWithFormat:@&quot;%s&quot;,__FUNCTION__])
#define __DZSuperResponseCMD__ DZCheckSuperResponseToSelector(__IMP_CLASS__, _cmd)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里定义了两个宏~~~&lt;strong&gt;IMP_CLASS&lt;/strong&gt;~~~用于指称当前方法实现所在的类，~~~&lt;strong&gt;DZSuperResponseCMD&lt;/strong&gt;~~~用于检查父类是否实现了该方法。&lt;/p&gt;

&lt;p&gt;测试一下，在A类中添加测试函数test2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void) test2
{
    if (__DZSuperResponseCMD__) {
        struct objc_super sup = {
            .receiver = self,
            .super_class = [self class]
        };
        void(*func)(struct objc_super*,SEL) = (void*)&amp;amp;objc_msgSendSuper;
        func(&amp;amp;sup, _cmd);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺利通过。&lt;/p&gt;

&lt;p&gt;现在可以使用上面构建的两个宏来做判断父类是否实现了特定方法的事情了。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>写于2016，那个2015年的尾巴</title>
        <link>http://dzpqzb.com/2016/01/09/xieyu2016.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2016/01/09/xieyu2016.html</guid>
        <pubDate>Sat, 09 Jan 2016 00:16:48 +0800</pubDate>
        <description>&lt;p&gt;这一年自己从深圳回了北京，从腾讯到了百度，也算是阴差阳错。没有那么的计较和思量，就这样回来了。在一个雾霾严重的城市，从六月份呆到了下一年。中间有段时间莫名奇妙的咳嗽，以为是北京的霾的缘故，所以去微信看了一下。只是，过了面试之后，自己又拒掉了offer。事后，发现这一年自己做的一些事情，大多如此，有头无尾。2015这一年就这样平平淡淡的过来了。事后，想想多少有些后悔，错过了一次非常不错的机会，那又如何，人总要为自己的事情的负责。无论好坏。总结一下自己的2015，在平淡中敲敲打打，码出了365个日落。&lt;/p&gt;

&lt;p&gt;这一年开始认真维护自己的博客，写一点关于iOS的技术文章和对技术与生活的感悟。&lt;/p&gt;

&lt;p&gt;这一年写了一本Gitbook的书《通过实现TableView理解iOS编程》。&lt;/p&gt;

&lt;p&gt;这一年维护了 iOS开发知识 公众账号，并拥有了很珍贵的800用户。&lt;/p&gt;

&lt;p&gt;这一年帮朋友在业余时间写了几个app。&lt;/p&gt;

&lt;p&gt;这一年在Github上终于有了第一个start过200的项目，也提交了很多自己有意思的项目。&lt;/p&gt;

&lt;p&gt;这一年开始认真的思考架构这个东西，对iOS的底层有了深一步的了解。&lt;/p&gt;

&lt;p&gt;不过，这一年依旧漂泊，依旧在寻找远方。而年岁渐长，也渐渐模糊了对于未来的概念。有很长一段时间，没有认真的思考过未来要去哪里，将来作何打算了。只愿下一年2016，能够过得有意义。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>类的外部初始化</title>
        <link>http://dzpqzb.com/2015/12/14/design-class-header-detail1.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/12/14/design-class-header-detail1.html</guid>
        <pubDate>Mon, 14 Dec 2015 14:35:39 +0800</pubDate>
        <description>&lt;p&gt;当在进行类的设计的时候，遇到传值的问题的时候，比如下述问题，我们通过VC1获取了用户的姓名，要向VC2进行传递。现在的一般做法是在定义VC2的时候，在头文件中暴漏name变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface B : UIViewController
@property (strong) NSString* name;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种做法，封装性很差，任何持有VC2实例的地方都能够修改这个name值，导致一些很奇怪的逻辑。&lt;/p&gt;

&lt;p&gt;其实这种情况应当属于外部初始化的典型应用。更好的方式就是我们就把name当成对象初始化必须的一个变量，需要对其进行初始化，那么就应当提供相应的函数来进行初始化。这样可以保持比较好的封装性。&lt;/p&gt;

&lt;p&gt;建议以后采取这样的方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// .h
@interface VC2 ： UIViewController
- （instancetype） init UNAVAILABLE;
-   （instancetype）initWithName:(NSString*)name;
@end

//.m
@interface VC2 ： UIViewController ()
{
     NSString* _name;
}
@end
@implatation VC2: UIViewController
-   （instancetype）initWithName:(NSString*)name
{
     self = [super init];
     if(!self) return self;
     _name = name;
     return self;
}
@end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在.h文件中进行变量声明的时候，如果不需要外部多次修改的变量，就不要暴漏了，做成私有变量，如果该变量初始化时所需的，那么就写成初始化函数哈。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>通过ViewController的关键流程来理解流程建模</title>
        <link>http://dzpqzb.com/2015/12/10/view-life-circle.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/12/10/view-life-circle.html</guid>
        <pubDate>Thu, 10 Dec 2015 13:13:36 +0800</pubDate>
        <description>&lt;p&gt;在最近解决某个问题的时候，发现在ViewDidDisappear中去获取self.navigationController为空。猛然间意识到，原来在VC的生命周期中存在一些细节问题需要注意。而且，最近一段时间，对基于流程（生命周期是特殊的流程）建模的编程思想也开始有些反思。所以就总结了一下VC生命周期的一些问题。&lt;/p&gt;

&lt;p&gt;先说点比较抽象的东西，关于流程建模的。对于同一个对象而言，往往在不同的业务场景中其有不一样的流程。换句话说，对于一个对象而言其可能出在多个流程中。比如我们拿一个VC来说：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每一个OC的实例都有其本身的生命周期——创建、使用、销毁&lt;/li&gt;
  &lt;li&gt;而对于VC来讲在处理内存问题的时候，还有其特有的ViewDidLoad，等过程&lt;/li&gt;
  &lt;li&gt;在处理页面展示的时候，也有ViewWillAppear等过程&lt;/li&gt;
  &lt;li&gt;….&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而在一个流程当中，每一个过程（一般会以函数表示）都有其特殊的职责。比如alloc用于非配内存，init用于初始化内存。而我们在这些函数中做的事情，也必须尽可能的和该函数的职责所匹配。一个被设计好的流程（通常会以一组函数的形式呈现），就像是一个插排。上面的每个插口都有自己适配的类型，如果你乱插，可能会有烧掉保险丝的危险。比如你在alloc中硬要做dealloc的事情。从设计模式的角度来说，这种思想叫做『控制反转』，是设计框架的时候常用的技巧，通过约束使用者的使用方式，来完成功能。而我们在使用UIKit等框架的时候，我们作为使用方，自然要接受这种『控制反转』。且能够在正确的地方做正确的事情。一句话说就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;恰如其分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同时，我希望通过阐释VC的一些生命流程和其使用细节的事情。也能激发读者对于基于流程建模的编程思想的反思。通过这种思想去反思在日常编程中，其他库中一些流程的使用。甚至是在自己进行程序设计的时候，能够也注意使用一下这种方式。&lt;/p&gt;

&lt;p&gt;好了下面我们就开始看看一个VC都有哪些流程需要注意的.btw，穷举所有的流程是一个费时费力的事情，所以会只摘几个比较关键的流程来描述和讲解。最重要的目的还是在于能够启发各位用流程建模这个视角来思考编程的一些问题：），偷懒了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;内存使用流程&lt;/h2&gt;
&lt;p&gt;VC的实例在内存使用上面，打的流程和其他对象实例的使用类似,都要经过下述的一些过程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;创建-&amp;gt;初始化-&amp;gt;使用-&amp;gt;销毁
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面的阐述也是类似，我们先说流程。然后再具体到函数的使用。因为我们在使用一个库或者框架的时候，首先要关注的是他的模型。尤其是流程模型。而具体的函数往往是在该模型基础上，实践下来的产物。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;(1)创建&lt;/h3&gt;

&lt;p&gt;苹果在内存处理上使用的是&lt;strong&gt;两段式&lt;/strong&gt;构造的思想：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;将创建和初始化分两步走&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创建的核心关注点在于内存分配。从堆栈上批出一块内存给对象使用。至于该对象，如何使用该内存（初始化）则是另外的函数的事情。经过创建和初始化两步之后，才能够给出一个干净可以使用的对象实例。&lt;/p&gt;

&lt;p&gt;在创建的时候，一般涉及到的函数为：
~~~
+ (instancetype)alloc
+ (instancetype)allocWithZone:(struct _NSZone *)zone
~~~
这两个函数为系统函数，我们不能重载该函数。这点是苹果在文档中格外强调的。因而，对于创建我们也只是调用一下系统函数的事情，没有太多自定义的工作需要我们去做。&lt;/p&gt;

&lt;h3 id=&quot;raiihttpbaikebaiducomitemraii&quot;&gt;(2)初始化 (&lt;a href=&quot;http://baike.baidu.com/item/RAII&quot;&gt;RAII&lt;/a&gt;)&lt;/h3&gt;
&lt;p&gt;初始化是两段式构造的第二步，对象实例只有经过该步骤之后，才是一个干净可以使用的对象。这种思想在很多编程语言中我们可以看到，比如C++。当然也有很多一段式构造的例子比如C语言。&lt;/p&gt;

&lt;p&gt;而在OC中，初始化使我们进行对象自定义操作的开始。这里我们需要初始化一些当前类特有的属性的值，以保证后续业务逻辑能够够正常。比如当我们从xib文件中加载VC的使用我们会使用到函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (instancetype _Nonnull)initWithNibName:(NSString * _Nullable)nibName bundle:(NSBundle * _Nullable)nibBundle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该函数将会通过传入的xib文件名和bundle来加载界面，并且初始化相关的数据。当然这是系统的函数。而我们更关注的是我们在这里应该做什么和可以做什么。&lt;/p&gt;

&lt;p&gt;说句废话：要做对象实例的初始化。主要是变量的赋值操作。&lt;/p&gt;

&lt;p&gt;For Exmaple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (instancetype) initWithNibName:(NSString *)nibNameOrNil
                          bundle:(NSBundle *)nibBundleOrNil
{
    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
    if (!self) {
        return self;
    }
    _payHandler = [BDWalletPayWebHandler new];
    _payHandler.enviromentWebViewController = self;
    return self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中我们在该函数中初始化了一个_payHandler的变量。而且细心的读者可能发现，我们用于初始化这个变量的值还不是外部传进来的，而是内部新生成的。这种方式我们称之为内部初始化。自然也会有外部初始化。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;内部初始化：变量的值在内部生成&lt;/li&gt;
  &lt;li&gt;外部初始化：用于初始化成员变量的值是在外部生成，然后传给&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而在实际的初始化场景中我们经常会发现这样的情况：在进行类的设计的时候，遇到传值的问题的时候，比如下述问题，我们通过VC1获取了用户的姓名，要向VC2进行传递。现在的一般做法是在定义VC2的时候，在头文件中暴漏name变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface B : UIViewController
@property (strong) NSString* name;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用的时候这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
B* vc = [B new];
vc.name = @&quot;xx&quot;;
[self.navigationController push:vc];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种做法，封装性很差，任何持有VC2实例的地方都能够修改这个name值，导致一些很奇怪的逻辑。而且往往是那种不可预期的变动。一旦出现bug查找起来极其困难。&lt;/p&gt;

&lt;p&gt;其实这种情况应当属于外部初始化的典型应用。更好的方式就是我们就把name当成对象初始化必须的一个变量，需要对其进行初始化，那么就应当提供相应的函数来进行初始化。这样可以保持比较好的封装性。&lt;/p&gt;

&lt;p&gt;建议以后采取这样的方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// .h
@interface VC2 ： UIViewController
- （instancetype） init UNAVAILABLE;
-   （instancetype）initWithName:(NSString*)name;
@end

//.m
@interface VC2 ： UIViewController ()
{
     NSString* _name;
}
@end
@implatation VC2: UIViewController
-   （instancetype）initWithName:(NSString*)name
{
     self = [super init];
     if(!self) return self;
     _name = name;
     return self;
}
@end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在.h文件中进行变量声明的时候，如果不需要外部多次修改的变量，就不要暴漏了，做成私有变量，如果该变量初始化时所需的，那么就写成初始化函数哈。因为@property这种语法的存在，削弱了OC中作用域的概念，从而导致了大家对于publick，private，protected等概念不是很清晰，从初始化这个事情上可见一斑。然，这些概念对于程序的健壮性又是多么的至关重要。还是应该拾起来的。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;常用的函数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;- init;
- (instancetype _Nonnull)initWithNibName:(NSString * _Nullable)nibName bundle:(NSBundle * _Nullable)nibBundle
- (instancetype _Nonnull) initWith****
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;init&lt;/code&gt;函数为所有OC对象都有的&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;(3)使用&lt;/h3&gt;

&lt;p&gt;关于使用这个其实是最重要的部分，而对象一旦创建并初始化完成之后，就可以嵌入到除了内存使用流程之外的流程之中。而在内存流程中我们所谓的使用，就是在其他流程中，对该内存对象进行的一系列的操作，包括且不止于：增删改查。&lt;/p&gt;

&lt;p&gt;对于使用的细节，可参考其他流程的介绍。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;(4)销毁&lt;/h3&gt;

&lt;p&gt;对象在完成使命之后，自然要被销毁，来释放其持有的资源。所谓有借有还再借不难，在创建过程中占用的内存，在初始化过程中持有的其他系统资源，在这个时候要做统一的释放。而且这是最后的释放时机，不然这个对象就成了小偷，会永久性的把资源偷走，比如在传统MRC的情境下，在init中分配是有了一个array，但是在dealloc中没有release，那么这个数组所占用的内存就写漏掉了。&lt;/p&gt;

&lt;p&gt;这里我们重提RAII，资源获取就是初始化。因为你获取了，你得释放啊。谁污染谁治理。所以申请和释放，创建和销毁是必须成对存在的。RAII是一个广义的资源管理概念，不至于内存。&lt;/p&gt;

&lt;p&gt;这个问题我们在Notification的使用中，经常会碰到crash的情况，一般都是因为没有正确的removeObser导致的脏内存引起的。我们可以把addObserve看成资源持有，而removeObserver看成资源释放。实际上也是如此，这对函数会对observe的引用计数进行加减操作。那么对于Notification这个事情也可以参考上述的流程来考虑。但这得和业务场景匹配才行，有些情况下接受通知可以伴随着对象的生命周期，建议在init-dealloc这对中注册取消。如果是伴随着UI显示而接收通知，则在didappear和diddisappear中进行最好（and在dealloc补充个取消，因为在navigation poptoroot的时候，中间的一些VC不会出发disappear等函数）。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;(5)异常&lt;/h3&gt;

&lt;p&gt;这个没有罗列在最初的那么内存流程模型当中，因为这样的，在建模的时候，首先要做的是让整个模型Work起来，而后再去处理各种边界问题。如果一上来就把精力集中在边界问题的处理上，就会无限制的放大问题的复杂度，增加处理的麻烦。&lt;/p&gt;

&lt;p&gt;而我们在看了基础的内存使用流程模型之后，在看在异常情况下apple是怎样处理的。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;初始化内存不足&lt;/h4&gt;

&lt;p&gt;直接返回nil&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;使用期间内存不足&lt;/h4&gt;
&lt;p&gt;我们这里之说iOS6.0以上的情况，6.0之后viewDidUnload等被废弃，而且目前市面上6.0以下的机器也快成古董了。&lt;/p&gt;

&lt;p&gt;当系统遭遇内存警告的时候，会调用VC的下述函数，在该函数内存，我们可以释放一些能够再次被创建的资源，比如维持的从网络或者数据库来的数据等等。
~~~&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}
~~~&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;视图管理流程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1ez0b3hn5jmj207o0egwf8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先来看一张比较大的图，这是apple目前提供的和View控制相关的一些函数的摘录（UIViewController中的函数).而这也是一个调用的时序关系图。VC的view还有其子View的创建使用，都在这个流程之中。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;流程解释&lt;/h3&gt;

&lt;h4 id=&quot;section-10&quot;&gt;创建根视图&lt;/h4&gt;
&lt;p&gt;当VC.view为空的时候，并且第一次调用vc.view的时候，会调用loadView函数来加载跟视图。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void) loadView
{
    self.view = [UIView new];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个函数中你可以使用self.view = **来对根视图进行赋值，而且建议也是只在这里进行根视图的赋值操作。因为一旦根视图确定后，外部会对根视图进行一些布局了之类的操作，如果在使用过程中随意的更换根视图，上述的这些操作将很难重放。导致界面的一些异常。&lt;/p&gt;

&lt;h4 id=&quot;section-11&quot;&gt;初始化根视图上子视图&lt;/h4&gt;
&lt;p&gt;当调用了loadView加载了根视图之后，系统会触发VC的ViewDidLoad函数。这个使用self.view已经有值，可以在其上addSubView了。&lt;/p&gt;

&lt;p&gt;在这里我们一般会做一些处理初始化子视图，并且addSubView之类的操作。注意布局的事情，就不要在这里做了，因为系统为我们提供了专门的函数来做这个事情。而且这个地方你拿到的self.view的frame信息是不准确的。比如刚才我们在loadView中没有对view进行布局初始化，给他设置一个frame。到了这个ViewDidLoad的地方的时候，你拿到的self.view.frame就是{0,0,0,0}。也就是说，你在这里进行布局的话，非常有可能是乱的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    _subView = [DZView new];
    _subView.backgroundColor = [UIColor whiteColor];
    [self.view addSubview:_subView];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-12&quot;&gt;布局&lt;/h4&gt;
&lt;p&gt;一般情况下，对于VC的根视图的操作是外部进行的，比如UINavigationController去push一个VC的时候，就会对vc.view.frame进行赋值，来控制VC的布局。而系统的这些试图控制器（导航了，之类的东西），都实现了CALayer的delegate，当vc的根视图的frame发生变化的时候会接受到通知&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- layoutSublayersOfLayer:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;系统的视图控制器会在这里面调用这两个函数来通知其当前的子VC去做布局的工作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- viewWillLayoutSubviews
- viewDidLayoutSubviews
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而这个子VC一般是我们创建的。在这两个函数里面我们去做布局的操作。这两个函数一个是在view本身的布局做完之前调用，一个是之后。无论哪个函数，这里面渠道的根视图的frame或者bounds信息都是准确的。&lt;/p&gt;

&lt;p&gt;而且，如果在这两个函数里面进行相对布局操作的话，将会让VC的根视图拥有适配不同屏幕的能力，同时当调整根视图的frame的时候，整个视图的布局也能够作出相应的变化。&lt;/p&gt;

&lt;h4 id=&quot;section-13&quot;&gt;显示流程&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;- viewWillAppear:
– viewDidAppear:
- viewWillDisappear:
- viewDidDisappear:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上述函数的字面意思理解：当视图被加载之后，要在window上显示出来，处于用户可见区域，或者离开用户可见区域的时候。系统将会调用VC相关函数来通知这种变化。&lt;/p&gt;

&lt;p&gt;我们去看viewWillDisappear的文档：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This method is called in response to a view being removed from a view hierarchy. This method is called before the view is actually removed and before any animations are configured.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而上述显示流程能够被触发是依赖系统的这套机制的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [vc willMoveToParentViewController:self];
    [self addChildViewController:vc];
    [self.view addSubview:vc.view];
    vc.view.frame = self.view.bounds;
    [vc didMoveToParentViewController:self];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而现在系统集中默认的试图管理器UINavitionController，UITabBarController,还有present方式，都是可以保证会使用上述机制来触发响应的显示逻辑的。在这些函数里面，我们可以做一些和显示相关的业务逻辑了。&lt;/p&gt;

&lt;p&gt;但是当你做业务逻辑的时候，一定要考虑这个函数在整个流程中的时序关系和他所代表的涵义。尤其是在每个视图管理器中的控制流程中，比如最开始提到的去获取self.navigationController为空的问题。&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;关于ViewController的关键的流程，先谈内存和视图管理这两个。当然其还有其他的一些流程，要说完有点太复杂了。希望通过上述的两个例子，能够展示一下流程建模在理解框架和使用框架上的一些的裨益。能够使用这种思想来思考日常的编程问题。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>如何进行技术方案优化</title>
        <link>http://dzpqzb.com/2015/11/28/optime-logic-method.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/28/optime-logic-method.html</guid>
        <pubDate>Sat, 28 Nov 2015 18:30:34 +0800</pubDate>
        <description>&lt;h1 id=&quot;section&quot;&gt;如何进行技术方案优化&lt;/h1&gt;

&lt;p&gt;首先这是一个很宏大的题目，我也只能窥其一斑。只说说自己的一些浅见和反思。因为之前有一段时间，在面对说要技术方案优化的时候，自己也有过一段不知所措的时期。后来才开始慢慢觉得自己找到点门道了，这片文章也算是自己的一个总结吧。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;什么是优化&lt;/h2&gt;

&lt;p&gt;首先我们先破题，来谈谈“优化”这个事情。通常情况下，我们说到优化的时候，往往会伴随着对之前系统的吐槽。或是不好用，或是性能低，或是用起来很麻烦。巴拉巴拉。是的，当我们对原先的系统有槽点的时候，我们会谈到“优化”。而“优化”的前提也是，之前已经有过一个东西存在，而且真对目前的场景应景不再适合。这个是有需要对原有系统进行调整，以满足当前的场景与需求。那么所谓优化即是：对原有系统进行有目的的改造。&lt;/p&gt;

&lt;p&gt;好吧，这听起来虽然说了什么，但其实什么都没说。因为这是一句大实话。&lt;/p&gt;

&lt;p&gt;but，我们仔细分析一下，我们要进行优化必须能够：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对原有系统的问题有所了解&lt;/li&gt;
  &lt;li&gt;了解目前场景和需求&lt;/li&gt;
  &lt;li&gt;有目的性的改造原有系统&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们来说一个我们通常会遇到的例子，也是在面试的时候会遇到的问题–“UItableView的性能优化”。其实每次有人问我这个问题，我内心都有千万只“草泥马”奔腾而过。没有具体的问题场景，只单单跑出来这样一个问题。是可以和他扯什么图片内存缓存了，避免圆角的使用了，预渲染，预加载了之类的东西。但是这些东西，真的对于在解决他们TableView卡顿的问题有效吗，不见得。套用《安娜卡列尼娜》一句话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;流畅的UItableView都是相似的，不流畅的UItableView各有各的不幸。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，吐槽到此为止。吐槽的目的是为了说明一点，你要进行优化，必须有一个特定的场景。在一个受限的范围内进行优化，因为这样目的是可控的。漫无边际的优化，和别人基于方法论的建议之类的东西，不一定对当前的问题有帮助。&lt;/p&gt;

&lt;p&gt;比如，之前我们在做的一个社交类的App中，首页使用了UItableView，老板说怎么用着这么卡顿。然后我们就开始了“优化”。&lt;/p&gt;

&lt;p&gt;首先，我们知道我们要优化的是第一个tab的tableview的滑动效率的问题。那总得有个监控的指标吧。对于程序猿来说，感觉这个不卡了，或者感觉这个卡，这个东西太模糊了。无法衡量啊。所以一定要量化。对于界面来讲就是大家常说的FPS，每秒帧率。于是我们测量了一下帧率，平均下来是25FPS。ou my god！的确是有点卡。&lt;/p&gt;

&lt;p&gt;然后我们知道对于ios来说如果能达到60FPS，那界面绝对不会有卡顿的感觉了。而很少有应用能达到这个水准。那么我们给自己设置了一个目标45FPS。btw,这个目标只是个阶段性目标。&lt;/p&gt;

&lt;p&gt;好了下面的过程，就是朝着这个目标前进了。当然我们知道，造成FPS较低的原因，一般都是主线程做了太多的事情，导致帧率降低。这只是个大方向。而对我们来讲，我们需要精准的知道，主线程都做了些什么事情，导致帧率降低。&lt;/p&gt;

&lt;p&gt;首先，我们发现的是，读取图片IO的过程发生在了主线程。IO过程一般是比较耗时的，于是我们像把该过程移到了后台线程中处理。发现帧率能够提高到33FPS，这还不够啊。革命尚未完成，同志仍需努力。&lt;/p&gt;

&lt;p&gt;之后的过程中，我们把布局预处理，还有圆角，数据预加载之类的事情做上去之后，终于基本达到45。阶段性目标完成。&lt;/p&gt;

&lt;p&gt;好了这是一个优化的例子：始于发现问题，止于目标达成。而重要的是其过程，描述问题！！！！&lt;/p&gt;

&lt;h2 id=&quot;or&quot;&gt;分析问题 (定性or定量)&lt;/h2&gt;

&lt;p&gt;其实，我一直比较坚信一句话：当你能够准确的描述一个问题的时候，你到解决问题就没剩几步了。比如刚才说的卡顿的问题，我们当时是这么描述的：图片读取发生了主线程，主线程中有一部分CPU片段用于文件读取和图片解码，造成主线程阻塞，从而导致帧率下降。当描述到这里的时候，解决方案就比较显而易见了，挪呗。搞到其他线程中之行。把主线程空出来。&lt;/p&gt;

&lt;p&gt;而上面的这个描述还只是一个定性的描述分析。只是阐述了现象。虽然能够解决了一个问题，但是对整体问题的贡献有多大，也未可知。所以我们可以当时完全可以这样描述：我们图片缓存在文件系统的平均大小是1MB，其读取时间为10.7ms，图片格式为jpeg，解码一个1M的图片耗时是60ms，而我们知道60FPS，每帧给主线程用来处理任务的CPU时间为17.7ms，也就说这个地方占用了大量CPU时间片来处理图片读与解码操作，从而造成了CPU阻塞，造成帧率没有达到60FPS。&lt;/p&gt;

&lt;p&gt;当我们使用定量的描述的时候，我们能够比较精确的知道，一个小问题，对于大问题来说到底意味着什么。而定量分析的方案中，当然包含了很多更多的细节信息，尤其是数据信息。这些也正是定量分析的优势所在。BUT，定量分析是一个非常耗时耗力的事情，你要拿到这么多的数据，你势必要付出很多时间，在采集这些数据上面。对于app开发来讲，除非公司给了足够的资源（尤其是时间），你才能像个研究者一样去采集这些数据，一般情况是，大概都会止步到定性分析这一步。其实这也是看具体问题而定了。&lt;/p&gt;

&lt;p&gt;不过无论你是使用定性分析的方式还是定量分析的方式。我们的目标是为了找到能够准确表述问题的方式，并且定位问题，以求找到解决方案。而为了达到这个目的一般情况下我们可以使用两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;你的编程功底和对iOS的了解程度都很深，那么完全可以从一些原理性的事情上去分析。我们称之为：逻辑分析法。&lt;/li&gt;
  &lt;li&gt;或许你的编程功底很深，或许很浅，或许你尝试分析而没有结果。那么可以使用改改代码试试的方法了。我们称之为：实验法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;逻辑分析法， 原理性分析&lt;/h3&gt;

&lt;p&gt;哈哈，套用马哲的一句话：事物是普遍联系的。既然是普遍联系的，不说必然存在因果，那么通过一定的逻辑分析。是可以找到他们之间的一些蛛丝马迹的关联的。这些关联或许可以解释一些什么。比如刚才卡顿的问题：原理就是主线程CPU被消耗过多，无法及时处理UI任务导致的。这只是一个例子。&lt;/p&gt;

&lt;p&gt;我们进行逻辑分析的目的，是为了找到我们的某些代码和问题之间的&lt;strong&gt;因果性&lt;/strong&gt;联系。就是说，我们能够明确知道造成UI卡顿的问题，就是因为IO的问题之类。这个话题说起来，比较深邃了。其中绝大部分实践的方法可以从《数理逻辑》这本书中找到。不过这是本讲数学的书，咱们得稍微换下脑子，把其中的定理，在编程中应用一下。因为我也只是意会了其中的某些东西，讲出来还没有那么功底。就只能麻烦各位自己去琢磨了。：）&lt;/p&gt;

&lt;h3 id=&quot;assume-action-response-test-assume&quot;&gt;实验法,Assume-Action-Response-Test-Assume&lt;/h3&gt;

&lt;p&gt;我称这个过称为&lt;strong&gt;AARTA&lt;/strong&gt;。这是一个一直往复的过程，在分析的过程中，你得一次次的重复这个过程来找到真正问题的所在。其实，这个方法比较常应用在改BUG这个场景上。其实如果从广义上讲，按照上面咱们对技术优化的定义，改bug也算是一种优化。只不过这个场景比价特殊而已。当无法准确的分析原理，或者当前程序的复杂性过高（低内聚高耦合）已经超出人脑的计算能力范围的时候，那么就可以“猜”了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7df22103jw1eyhrrytgv2j209408g3yn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;assume&quot;&gt;（1）假设 assume&lt;/h4&gt;

&lt;p&gt;根据以往的经验来，设定一个和问题域相关的假设。比如UI卡顿的问题，你怀疑是不是因为图片的问题呢。那么现在就假设是图片的问题！&lt;/p&gt;

&lt;h4 id=&quot;action&quot;&gt;（2） 尝试进行修改  action&lt;/h4&gt;

&lt;p&gt;既然假设是图片的问题，那么就把UIImageView从Cell上删掉吧。&lt;/p&gt;

&lt;h4 id=&quot;response&quot;&gt;（3）看程序的反馈 Response&lt;/h4&gt;

&lt;p&gt;重新运行一遍程序，看一下程序运行的效果。FPS是否有所改善，而且改善的幅度有多大。&lt;/p&gt;

&lt;h4 id=&quot;test&quot;&gt;（4）Test&lt;/h4&gt;

&lt;p&gt;根据，程序的反馈和我们预先设定的目标来判断一下，当前改动是否满足了我们设计的目标。如果有，那么你大概就找到了问题的一个原因。如果没有那么进行下一步。&lt;/p&gt;

&lt;h4 id=&quot;assume-1&quot;&gt;（5） 重新提出假设 Assume&lt;/h4&gt;

&lt;p&gt;既然不是图片的问题，那么会不会是其他事情上耗费了CPU呢。比如布局样式的计算。那么重新假设是局部样式的问题。在执行（2）过程。&lt;/p&gt;

&lt;p&gt;所谓实验，即是大胆假设，小心取证，如此往复，以求终解。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;监控&lt;/h2&gt;

&lt;p&gt;上面只是进行了一些方法论的探讨。但是有一件事情，是若要优化一定要做的。那就是“监控”。&lt;/p&gt;

&lt;p&gt;监控是个非常重要的东西。&lt;/p&gt;

&lt;p&gt;监控是个非常重要的东西。&lt;/p&gt;

&lt;p&gt;监控是个非常重要的东西。&lt;/p&gt;

&lt;p&gt;重要的事情说三遍。尤其是对于运行在生产环境的程序。这就像是一个体检，你得实时掌控程序的运行情况，知道问题出在了哪里，甚至有些时候知道：哎呀，出问题了。没有监控，程序一旦上线之后，就像脱缰的野马，跑到哪里，做了什么，你就是一头忙然了。突然有一天，老板说有人反馈咱们的app经常崩溃，当你没有crash监控，这个你都不知道从哪里查起。&lt;/p&gt;

&lt;p&gt;而且，监控也是优化的数据来源。他能够通过数据的指标来非常直观的告诉你，程序哪里有问题，你优化之后，效果是怎样的。现在网上有很多这方面的服务提供出来，比如bugly之类的，甚至有些是APM（application performance manager)，直接监控到程序的运行状态和性能。google一下，能搜出不少来。可以酌情，应用在自己开发的app中。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;说了半天，总结一下。优化是在可控的范围内有目的性的对现有程序的修改。一般可以使用逻辑分析法和实验法来定位、分析、描述问题。或者定性或者定量。无论哪种，要想优化，你得先建立起对自己app运行的监控体系。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>iOS开发知识框架</title>
        <link>http://dzpqzb.com/2015/11/27/zhishikuangjia.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/27/zhishikuangjia.html</guid>
        <pubDate>Fri, 27 Nov 2015 22:39:11 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7df22103jw1eyfwulrmn3j21ay3nihd3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Bitcode适配指南</title>
        <link>http://dzpqzb.com/2015/11/19/bitcode-open.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/19/bitcode-open.html</guid>
        <pubDate>Thu, 19 Nov 2015 19:41:34 +0800</pubDate>
        <description>&lt;p&gt;随着XCode7的发布，Apple提供了一项新的技术来支持App瘦身功能，那就是Bitcode。本文章将会结合自己在支持bitcode过程中遇到的问题，来阐述支持bitcode的过程。&lt;/p&gt;

&lt;h2 id=&quot;bitcode&quot;&gt;BitCode是什么&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.

Xcode hides symbols generated during build time by default, so they are not readable by Apple. Only if you choose to include symbols when uploading your app to iTunes Connect would the symbols be sent to Apple. You must include symbols to receive crash reports from Apple.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述引自Apple的文档&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35&quot;&gt;App Thinning (iOS, tvOS, watchOS)&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;其大概意思是Bitcode类似于一个中间码，被上传到applestore之后，苹果会根据下载应用的用户的手机指令集类型生成只有该指令集的二进制，进行下发。从而达到精简安装包体积的目的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7df22103jw1ey79g6evsij20kb08rmxg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;一点编译原理&lt;/h3&gt;

&lt;p&gt;为了更好的理解什么是bitcode，我们简短的看一下编译器编译的过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Lexer&lt;/strong&gt; :读入源文件，并将其转化成字符流&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Parser&lt;/strong&gt; :将字符流转换成&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;AST&lt;/a&gt;（抽象语法树）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Semantic Analysis&lt;/strong&gt;: 对输入的AST进行语法检查。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Code Generation&lt;/strong&gt;: 代码生成，将AST转换成低层次的IR指令&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Optimization&lt;/strong&gt;: 分析IR指令，将其中潜在会拖慢运行速度的指令干掉。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AsmPrinter&lt;/strong&gt;: 通过IR（中间码）生成特定CPU架构的汇编代码&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Assemble&lt;/strong&gt;: 将汇编代码转化成二进制&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Linker&lt;/strong&gt;: 通常程序会引用其他的二进制文件（.a或者framework)，但是这些链接在程序中没有正确的地址，只是个占位符。Linker的工作就是给这些占位符正确的地址。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;更多信息可以参考：&lt;a href=&quot;https://www.objc.io/issues/6-build-tools/compiler/&quot;&gt;The Compiler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一般情况下，在真实的编译器构架那种，会将上述过程分成前端和后端两部分来处理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1eyd62a1opyj21f816sn5d.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在前后端之间传递的就是IR（中间码），而bitcode就是一种特殊形式的中间码。原本前后端的工作都是在本地LLVM中完成，虽然Apple没有给出具体的Bitcode实现，但是通过他们的文档可以猜测，是将一部分后端的工作移到了服务器进行。从Xcode上传IR到服务器，服务器来真对不同的机型进行后续操作。从而达到真对不同机型生成对应指令集的二进制，而减小报体积的目的。&lt;/p&gt;

&lt;h2 id=&quot;bitcode-1&quot;&gt;打开bitcode设置&lt;/h2&gt;

&lt;p&gt;实际上在Xcode 7中，我们新建一个iOS程序时，bitcode选项默认是设置为YES的。我们可以在”Build Settings”-&amp;gt;”Enable Bitcode”选项中看到这个设置。&lt;/p&gt;

&lt;p&gt;不过，我们现在需要考虑的是三个平台：iOS，Mac OS，watchOS。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对应iOS，bitcode是可选的。&lt;/li&gt;
  &lt;li&gt;对于watchOS，bitcode是必须的。&lt;/li&gt;
  &lt;li&gt;Mac OS不支持bitcode。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果我们开启了bitcode，在提交包时，下面这个界面也会有个bitcode选项：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1ey79j7ofbzj20lm0awmz1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是如果其中包含第三方库，不支持bitcode时候。需要将”Enable BitCode”设置成NO。而且这个选项是，只要有一个第三方库不支持，就不能开的。否则连接错误。&lt;/p&gt;

&lt;h2 id=&quot;fembed-bitcode-fembed-bitcode-maker&quot;&gt;确保打包的时候使用的是&lt;code&gt;fembed-bitcode&lt;/code&gt;, 而不是&lt;code&gt;fembed-bitcode-maker&lt;/code&gt;&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;You should be aware that a normal build with the -fembed-bitcode-marker option will produce minimal size embedded bitcode sections without any real content. This is done as a way of testing the bitcode-related aspects of your build without slowing down the build process. The actual bitcode content is included when you do an Archive build.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;fembed-bitcode-maker&lt;/code&gt;:只是简单的标记一下在archive出来的二进制中bitcdoe所在的位置。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;fembed-bitcode&lt;/code&gt;: 真的会生成bitcode指令，并且嵌入到二进制中，这个设置不止要在app中设置，同样你也必须在编译静态链接库的时候使用。而且需要主题的是&lt;strong&gt;该参数系统只默认在archive模式下会添加&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是bitcode只默认在archive下编译。在debug和release下并不会。&lt;/p&gt;

&lt;p&gt;如果您开发的是app那么走正常的打包archive流程就好了。如果你正在开发.a静态库或者framework，请注意打包方式设置为archive,或者在打包脚本中加入-fembed-bitcode参数。如果需要的话，需要在Build Settings中打开 DEPLOYMENT_POSTPROCESSING=YES，设置Strip Style为debugging。&lt;/p&gt;

&lt;h2 id=&quot;bitcode-2&quot;&gt;检测是否打开Bitcode&lt;/h2&gt;

&lt;p&gt;当打开bitcdoe选项之后，我们可以使用otool工具来检查二进制文件中是否包含bitcode段。&lt;/p&gt;

&lt;h3 id=&quot;a&quot;&gt;针对于静态链接库.a文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;otool -arch armv7 -l xxxx.a | grep __bitcode | wc -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是当前库支持.a文件则会输出一个数字&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/7df22103jw1ey7d1wkb9aj21a7032gmo.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果不支持bitcode则不会出现该数字。&lt;/p&gt;

&lt;p&gt;上述命令只检查了armv7架构，同时，也必须使用改指令检查其他的指令集是否包含bitcode如：arm64，armv7s等等&lt;/p&gt;

&lt;h3 id=&quot;appframeworkbitcode&quot;&gt;检查app或者framework中是否包含bitcode&lt;/h3&gt;

&lt;p&gt;由于app中二进制和framework中二进制文件与.a文件存在差异，因为需要检查的是__LLVM段，当出现该段的时候，则表示支持bitcdoe，否则不支持。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;otool -l xxxx | grep __LLVM | wc -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里otool有个bug，当你的framework使用过lipo命令，进行拆解和合并之后，需要指定指令集进行检查才可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;otool -arch armv7 -l xxxx | grep __LLVM | wc -l
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;BUT, 上述检查过了之后，也不一定是真的支持bitcode，在实际的测试中，发现上述检测命令通过之后，某个使用的第三方库，依然报错不支持bitcode。因而最终结果，还是需要以是否能够连接成功为准。重要事情说三遍，上述网上流传的检测方法只做参考，最终还是要以实际效果为准。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;最终结果检查&lt;/h3&gt;

&lt;p&gt;如果您是一个APP，可以直接进行Archive打包，如果是一个库，则建议建一个Demo工程进行打包，记得要打开bitcode设置。&lt;/p&gt;

&lt;h4 id=&quot;checkpoint1--&quot;&gt;CheckPoint1  连接是否报错&lt;/h4&gt;

&lt;p&gt;如果有任何一个库没有打开bitcode链接，将会出现类似下方的错误。只要链接过了，那么恭喜了，基本上是OK了。
&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1eyc7gbmexbj21fy04o7as.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;checkpoint2-&quot;&gt;CheckPoint2 检查最终效果&lt;/h4&gt;

&lt;h5 id=&quot;ipa&quot;&gt;使用开发模式导出ipa&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/7df22103jw1eyc7nexdfbj206t07qmxo.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/7df22103jw1eyc7o22jrtj20g409qmyv.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;选择出包的方式&lt;/h5&gt;

&lt;p&gt;这里建议使用第二种，生成真对具体机型的包&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7df22103jw1eyc7occxdqj20g409q408.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;compiling-bitcode&quot;&gt;出现了，Compiling Bitcode，这个过程！！！！！&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1eyc7pqgxolj20g409q3ys.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;最终结果&lt;/h5&gt;

&lt;p&gt;在最后输出的文件中，你能够看到一个App Thinning的结果，里面有针对各个机型的ipa包。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7df22103jw1eyc7r9u55sj20b809575p.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在App Thinning Size Report中能够明显看到，由于使用了bitcode等技术之后，所带来的收益：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
App Thinning Size Report for All Variants of Black

Variant: Black-iPad (4th generation)-etc.ipa
Supported devices: iPad (3rd generation) and iPad (4th generation)
App + On Demand Resources size: 368 KB compressed, 737 KB uncompressed
App size: 368 KB compressed, 737 KB uncompressed
On Demand Resources size: Zero KB compressed, Zero KB uncompressed
....
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>是怎样干掉支付宝的界面的</title>
        <link>http://dzpqzb.com/2015/11/17/kill-alipay.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/17/kill-alipay.html</guid>
        <pubDate>Tue, 17 Nov 2015 22:25:03 +0800</pubDate>
        <description>&lt;p&gt;这边的产品需求，需要在某些场景下进行清场操作，将所有的ViewController堆栈清空，页面回滚到首页。我们内部的页面都能够完成这个操作。但是有些第三方的页面，怎么都搞不掉。比如支付宝的页面。因为是引入的SDK，没有代码，所以第一方案，向支付宝侧提出需求，要求提供一个函数接口，能够清退他们的界面，但是他们说不能满足该需求。所以，我们只能开始了黑科技之旅。&lt;/p&gt;

&lt;h2 id=&quot;view&quot;&gt;首先寻找支付宝的View&lt;/h2&gt;

&lt;p&gt;因为我们的目标是干掉支付宝SDK自己弹出来的页面，那么我们第一件事情就是找到该页面。我们使用Xcode7.1的视图查看功能，找到了支付宝的View：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/7df22103jw1ey5jykdse8j20b80a0dh4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个叫做APayH5WebViewProgressView的东西，一看就是支付宝WebView上的进度条。他的父View是个UIView，很明显这个是某个UIViewController的根view。而且这个View很奇怪的是直接加载了Window上面。好霸道！！！怪不得我们的界面都被盖住了。&lt;/p&gt;

&lt;p&gt;也就是说现在我们只要把这个VC的view给remove掉就可以干掉支付宝的霸道的页面了。而现在这个页面没有什么特异性的信息。但是可以推理那个UIViewController一定是某个特殊的类，自有其类名。而且因为是直接addSubView在keywindow上的，则必然在某个地方会持有该VC的实例。发现支付宝的AlipaySDK是个单例，这可是个常驻内存的东西。如果什么东西要被持有的话，肯定和他脱不了干系。要不看看这个类的实例变量吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
- (void) printClassIVar:(NSString*)name
{
    unsigned int count ;
    Ivar *list = class_copyIvarList(NSClassFromString(name), &amp;amp;count);
    for (int i = 0; i &amp;lt; count; i++) {
        Ivar p = *list;
        const char* name = ivar_getName(p);
        NSLog(@&quot;name is %s \t  type is  %s&quot;, name, ivar_getTypeEncoding(p));
        list++;
    }
}
- (void) testAlipay
{
    [self printClassIVar:@&quot;AlipaySDK&quot;];
//
//    id value = [[AlipaySDK defaultService] valueForKey:@&quot;bizContext&quot;];
//    

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
 name is _schemeStr        type is  @&quot;NSString&quot;
 name is _executingOrderStr        type is  @&quot;NSString&quot;
 name is _completionBlock          type is  @?
 name is _route    type is  @&quot;APayRoute&quot;
 name is _processor        type is  @&quot;APayProcessor&quot;
 name is _alertOkAction    type is  @&quot;NSDictionary&quot;
 name is _alertCancelAction        type is  @&quot;NSDictionary&quot;
 name is _bizContext       type is  @&quot;APayBizContext&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到AlipaySDK这个单例持有的变量实例中有几个比较特殊：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;APayRoute&lt;/li&gt;
  &lt;li&gt;APayBizContext&lt;/li&gt;
  &lt;li&gt;APayProcessor&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这三个类一看就是支付宝的类，我们用上面类似的方法，查看这三个类的属性变量，就真的发现了一个webViewController。&lt;/p&gt;

&lt;p&gt;APayRoute的属性变量结构：
~~~
 name is _infostr          type is  @”nsstring”
 name is _schemestr        type is  @”nsstring”
 name is _resultblock      type is  @?
 name is _wapviewcontroller        type is
~~~&lt;/p&gt;

&lt;p&gt;没错就是那个wapviewcontroller。不管怎样我们找到这个VC了。那么剩下的就是干掉他了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;删掉界面&lt;/h2&gt;

&lt;p&gt;其实就是从AlipaySDK的单例这段内存开始，一直往下找实例。直到找到这个VC为止。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    id cla = NSClassFromString(@&quot;AlipaySDK&quot;);
    if ([cla respondsToSelector:@selector(defaultService)]) {
        id defaultService = [cla performSelector:@selector(defaultService)];
        id value = [defaultService valueForKey:@&quot;route&quot;];
        if ([value isKindOfClass:NSClassFromString(@&quot;APayRoute&quot;)]) {
            if ([value respondsToSelector:@selector(wapViewController)]) {
                UIViewController* vc = [value performSelector:@selector(wapViewController)];
                if (vc) {
                    [vc.view removeFromSuperview];
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后直接用removeFromSuperview删掉这个霸道的页面。&lt;/p&gt;

&lt;p&gt;-&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Block使用的陷阱</title>
        <link>http://dzpqzb.com/2015/11/17/block-usage.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/17/block-usage.html</guid>
        <pubDate>Tue, 17 Nov 2015 12:16:47 +0800</pubDate>
        <description>&lt;p&gt;使用block的使用，一定要考虑到对象的生命周期，block会延长对象的生命，延迟释放，由此可能会造成逻辑上时序的问题。我自己在使用的时候命中了这样的一个问题，因为对象延迟释放导致逻辑有问题。block的时候留意一下。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>什么时候该使用枚举类型</title>
        <link>http://dzpqzb.com/2015/11/12/emun-usage-when-and-how.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/12/emun-usage-when-and-how.html</guid>
        <pubDate>Thu, 12 Nov 2015 16:34:02 +0800</pubDate>
        <description>&lt;p&gt;&lt;strong&gt;在值可穷尽的情况下可使用枚举类型&lt;/strong&gt;
当场景能够全覆盖的时候才使用枚举类型，比如付款状态：付款前，付款中，付款后，中前后三个状态能够覆盖所有付款的时间场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;值在不可穷尽的情况下不适合使用枚举。请考虑其他方式或者设计模式来解决当前问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而付款失败的种类，则不适合使用枚举类型，因为枚举无法覆盖全量的失败场景，在1.0版本的时候可能只有2，3，5这几种失败code，到了2.0的时候又多了6，8，9，。。。。如此类推，你会面临着不停的往这个枚举中添加新的值的窘境。而且在处理这个枚举的switch-case语句也会不断的膨胀，带来维护灾难。&lt;/p&gt;

&lt;p&gt;而我们在使用枚举的时候，通常会伴随着switch-case这种变形的if语句，通常当一个if语句嵌套超过3层的时候，就考虑一下这里是否存在问题了。于是我们我们使用枚举加switch-case来判断场景的情况。也是值得商榷的。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>OC中使用defer操作</title>
        <link>http://dzpqzb.com/2015/11/11/defer-ios-caozuo.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/defer-ios-caozuo.html</guid>
        <pubDate>Wed, 11 Nov 2015 21:32:15 +0800</pubDate>
        <description>&lt;p&gt;类似于 golang的defer  将一个操作延迟到作用域结束的时候 执行：常见于 关闭文件等。。。。这是异常处理的一种替代方案。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define DEFER(block) __unused OCDefer* defer___ = [[OCDefer alloc] initWithBlock:block];

typedef void(^OCDeferBlock)(void);

@interface OCDefer : NSObject

- (instancetype) initWithBlock:(OCDeferBlock)block;

@end

@interface OCDefer ()

{

    OCDeferBlock _block;

}

@end

@implementation OCDefer

- (instancetype) initWithBlock:(OCDeferBlock)block

{

    self = [super init];

    if (!self) {

        return self;

    }


    _block = block;

    return self;

}

- (void) dealloc

{

    if (_block) {

        _block();

    }

    _block = nil;

}

@end

//测试的例子

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions

{


    FILE* file = fopen(&quot;/afile.txt&quot;, &quot;r&quot;);

    DEFER(^{

        NSLog(@&quot;hello&quot;);

        fclose(file);

    });


    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

    // Override point for customization after application launch.

    self.window.backgroundColor = [UIColor whiteColor];

    [self.window makeKeyAndVisible];

    return YES;

}

&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>使用宏来减少代码重复</title>
        <link>http://dzpqzb.com/2015/11/11/macro-defines.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/macro-defines.html</guid>
        <pubDate>Wed, 11 Nov 2015 21:14:06 +0800</pubDate>
        <description>&lt;p&gt;使用宏定义来简化输入，提高输入的效率。同时提高输入准确性。&lt;/p&gt;

&lt;p&gt;案例一 属性定义 @property&lt;/p&gt;

&lt;p&gt;我们在定义一个类的属性的时候，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface TestObject : NSObject

@property (strong, nonatomic) NSString* title;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最起码要输入5个单词，四个符号和多个空格。写多了就会觉得这里重复输入的地方太多，为什么不想个办法优化一下输入呢。而且有些时候，中间的某个单词比如strong拼错了，还得会过头来继续修改。 优化输入效率，有很多种方式。比如使用sinepts。而且xcode的snip支持也不错。直接拖拽代码块就能够生成snip。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\\key is

\\@propertystrongnonatomic

@property (strong, nonatomic) &amp;lt;#type#&amp;gt;* &amp;lt;#name#&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的确是可以，但是你需要定义大量的snip来适应不同的定义peroperty的情况。那有没有更简单的一点的方法呢。必须有啊，使用宏啊。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define DEFINE_PROPERTY(mnmKind, type , name)       @property (nonatomic, mnmKind)  type  name

#define DEFINE_PROPERTY_ASSIGN(type, name)          DEFINE_PROPERTY(assign, type, name)

#define DEFINE_PROPERTY_ASSIGN_Double(name) DEFINE_PROPERTY_ASSIGN(double, name)

#define DEFINE_PROPERTY_STRONG(type, name) DEFINE_PROPERTY(strong, type, name)

#define DEFINE_PROPERTY_STRONG_NSString(name) DEFINE_PROPERTY_STRONG(NSString*, name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体参见DZProgrameDefines 我们完全可以通过使用宏定义，来扩展出一些列的定义属性的宏方法，借助于XCode的强大的自动补全来方便我们输入，少敲了非常多的字符。并且还减少了出错的情况，在可读性上，如果宏定义的名字起得好，可读性也不错。&lt;/p&gt;

&lt;p&gt;同时，不得不说的一点是我们借助于这种宏定义的方式，还规范和统一了定义属性的格式，方便维护同一个工程的多个同事修改同一份代码。让他们的代码质量能够保持在一个比较整齐的水平。 这种&lt;/p&gt;

&lt;p&gt;代码模板&lt;/p&gt;

&lt;p&gt;某些情况下，我们可能会写一些大量的重复代码，而这些代码又很难将其抽离出来做成一个独立的函数（甚至是lambda表达式），而这种时候宏的作用就体现出来了。考虑下述情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString* a = infos[@&quot;aKey&quot;];

if(!a) {

    [self postError:@&quot;need aKey&quot;];

    return;

}

NSString* b = infos[@&quot;bKey&quot;];

if(!b) {

    [self postError:@&quot;need bKey&quot;];

    return;

}

....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码中，我们需要从字典infos中取一批参数并且要判断这些参数是否为空，为空的时候报错并返回。其中有大量的代码是重复的。而这种重复又不太适合抽离成函数那么这个时候就可以这样做了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define GetValueWithLocalNameAndKey(name , key) \

\

NSString* name = [infos getWBValueForKey:key error:&amp;amp;error];\

if (!error) { [self postPayError:error]; return;}\

\

...

GetValueWithLocalNameAndKey(a,aKey);

GetValueWithLocalNameAndKey(b,bKey);

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做的时候，就将一段代码抽离成了模板。方便了使用和维护。&lt;/p&gt;

&lt;p&gt;-&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>ARC的一些细节之NSError的使用</title>
        <link>http://dzpqzb.com/2015/11/11/arc-error.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/arc-error.html</guid>
        <pubDate>Wed, 11 Nov 2015 21:10:40 +0800</pubDate>
        <description>&lt;p&gt;首先看一下这段代码会输出一些什么：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSError* error;
NSError** errPtr = &amp;amp;error;
NSLog(@&quot;%x&quot;,errPtr);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你认为，能够输出error的地址的话，也是情有可原的。但是，实际情况是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exxcepvhjrj20fk00zt8r.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;编译器直接报错，编译都不通过，也就谈不上运行输出结果了。为什么会这样呢？&lt;/p&gt;

&lt;p&gt;在ARC下每个变量都有一个所有权修饰符默认是__strong，而在定义OC对象的指针变量的时候，需要注意其所有权修饰符需要与其所指向的对象的所有权修饰符保持一致。于是上面的代码需要改成这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    NSError* error;
    NSError* __strong * errPtr = &amp;amp;error;
    NSLog(@&quot;%x&quot;,errPtr);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到这你也许会问，经常遇到到使用NSError来返回错误信息的函数，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)verifyPassword:(NSString *)inPassword error:(NSError **)outError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么调用他的时候没有报错呢？&lt;/p&gt;

&lt;p&gt;因为在函数使用的时候，会默认的将outError的所有权变成__autoreleasing.并且在调用函数之前编译器回补齐一个临时变量，从而达到了所有权修饰符保持一致的效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)verifyPassword:(NSString *)inPassword error:(NSError *__autoreleasing*)outError {
    ....
}
....
{
    NSError __strong* error;
    NSError __autoreleasing* tmp = error;
    [anObject verifyPassword:@&quot;a&quot; error:&amp;amp;tmp];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个问题，在使用NSError或者使用指针在ARC下进行数据传递的时候，需要注意和小心。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>MAC下面提高工作效率的一些非常好用的工具</title>
        <link>http://dzpqzb.com/2015/11/11/tools-for-program.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/tools-for-program.html</guid>
        <pubDate>Wed, 11 Nov 2015 21:05:51 +0800</pubDate>
        <description>&lt;p&gt;编程相关：&lt;/p&gt;

&lt;p&gt;xcode（oc的神奇，ios编程必备，并且支持多种语言，写c++/c什么的都可以）&lt;/p&gt;

&lt;p&gt;Code2 （界面简单，写网页，js可以考虑）&lt;/p&gt;

&lt;p&gt;Prototyper（原型设计软件，可以说是现在原型设计软件中真对移动端开发优化的最好的，最强大的是他能设计动画，让原型不再只是一张张页面。）&lt;/p&gt;

&lt;p&gt;MesaSQLite（查看SQLite文件的利器，调试sqlite时必备）&lt;/p&gt;

&lt;p&gt;Sketch（现在都到3了，比PS轻巧方便，对于我这样没有美术功底的人来说，都能用它来给ios抠图了，哈哈）&lt;/p&gt;

&lt;p&gt;编辑器和排版：&lt;/p&gt;

&lt;p&gt;Sublim Text2/3 (在textmate好长时间不更新之后，mac上目前最好的编辑器，经过扩展后，可编程一个IDE。其插件机制让他无所不能，什么VIM模式了，语法高亮了，，，，都OK)&lt;/p&gt;

&lt;p&gt;Atom（Github推出的基于浏览器建构的编辑器，简单试用了一下，和Sublim的感觉差不多，但是在很多细节处理上优于Sublim，只是现在还在开发中，非常期待其完成版）&lt;/p&gt;

&lt;p&gt;Latex+Textmake+lyx(所想即所得的排版工具，尤其是写数学公式极其漂亮，缺点是入门门槛有点高，但是一旦学会绝对可以伪装自己成文艺青年。大神Knuth出品，没有更好只有最好)&lt;/p&gt;

&lt;p&gt;Markdown+Mou（简单的编辑和排版工具，一般情况下的任务都可以胜任，而且学习门槛低，非常易用。那个，自从用了markdown好久没有用latex了。）&lt;/p&gt;

&lt;p&gt;OmmWriter（文艺青年必备，让打字成为一种享受）&lt;/p&gt;

&lt;p&gt;Google Docs 大家一起编辑同一个文档&lt;/p&gt;

&lt;p&gt;版本控制：&lt;/p&gt;

&lt;p&gt;SourceTree（Git版本控制工具，简单易用，功能强大，基本上是Mac最好的了git软件了）&lt;/p&gt;

&lt;p&gt;Cornerstone（SVN版本控制工具，一样强大）&lt;/p&gt;

&lt;p&gt;Cocoapods（ios/Mac编程中，第三方库管理，比git的submodule和svn的外部链接方便多了，ios程序员必备）&lt;/p&gt;

&lt;p&gt;脚本语言:&lt;/p&gt;

&lt;p&gt;apple script（做一些简单的自动化的时候可以使用，语法极度简单，基本和说英语没区别，上手难度比bash和python等小多了，简单了解之后，即可使用。而且很多apple程序都支持apple script调用）&lt;/p&gt;

&lt;p&gt;文档查看：&lt;/p&gt;

&lt;p&gt;Dash（mac上最好的文档查看工具，没有之一。可以通过插件嵌入到xcode，vim。。。等其他软件中，一键唤起查询。结合Alfred使用，效果更佳）&lt;/p&gt;

&lt;p&gt;终端软件：&lt;/p&gt;

&lt;p&gt;iTerm2（非常好用的终端软件，主题可以美化，直接选择字符串就能够复制。。。。）&lt;/p&gt;

&lt;p&gt;tmux（高频率使用终端的人都有一个痛，不同任务需要打开不同的窗口，往往整个屏幕上层层叠叠的铺满了串口，搞过linux的人可能知道有个awosome的平铺式窗口管理器，在一个屏幕中平铺的展示多个窗口，极大限度的利用屏幕空间，显示更多的内容，而tmux这个软件就实现了在终端中的平铺式窗口管理，简单易用，可扩展性强。）&lt;/p&gt;

&lt;p&gt;vim（大家都懂得，神器）&lt;/p&gt;

&lt;p&gt;任务管理和笔记软件：&lt;/p&gt;

&lt;p&gt;WunderList（苹果某年的最佳软件，跨平台，简单易用，界面很漂亮。简单的任务管理。）&lt;/p&gt;

&lt;p&gt;Evernote （跨平台，知识积累和管理非常好的工具）&lt;/p&gt;

&lt;p&gt;Xmind（在思维脑图领域无论哪个平台这个是最好的了吧）&lt;/p&gt;

&lt;p&gt;ReadKit（自从google reader关了之后，订阅rss看资料就全靠它了。支持各种源，简单而不失强大）&lt;/p&gt;

&lt;p&gt;系统相关：&lt;/p&gt;

&lt;p&gt;Alfred V2（替代苹果自带的spotlight，全局搜索各种东西，只有你想不到没有你搜不到，PM2.5都能搜，里面的Workflow可以用来扩展神奇的功能，只能说你用了才会知道他的好。貌似新版的MAC QQ中也集成了类似的功能，只能说既生瑜何生亮了。）&lt;/p&gt;

&lt;p&gt;ParallelDesktop(用了之后我才知道什么叫做虚拟机，奥，不对应该是硬件共享。体验流畅，使用简单。可以将Windows、linux和Mac桌面完美的无缝粘合。顺便一说，你要想在Mac上完windows游戏的话，必备)&lt;/p&gt;

&lt;p&gt;1Password（这个每个网站都要密码的年代的救世主，只需要记住一个密码，其他的密码他帮你记住。密码管理界的老大哥。）&lt;/p&gt;

&lt;p&gt;f.lux（一个小工具根据当前时间和你的位置调整屏幕色温的，保护眼睛用的，程序猿的贴心保姆）&lt;/p&gt;

&lt;p&gt;Time Out （时间提醒工具，比如半个小时告诉你一次该起来运动一下了）&lt;/p&gt;

&lt;p&gt;CleanMyMac（系统清理工具，我在128G硬盘的情况下，能够正常运行系统和编程，全指望他帮助我删除无用文件了）&lt;/p&gt;

&lt;p&gt;Chrome（浏览器，个人感觉比safari好用）&lt;/p&gt;

&lt;p&gt;干坏事必备：&lt;/p&gt;

&lt;p&gt;File Viewer（二进制文件查看，分支别人的程序和数据）&lt;/p&gt;

&lt;p&gt;iExplorer（本来是ios设备管理工具，但是能够从设备中导出别人的程序，导出之后的事情，就自己想象了）
其他：事情MAC OS很多系统自带的应用都非常好用，日历，邮件什么的能用原生的尽量用原生的。能买个正版就买个正版吧，大家改BUG都挺不容易的。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>解决Instruments无法找到调试符号表的问题</title>
        <link>http://dzpqzb.com/2015/11/11/instruments-symbols-problem.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/instruments-symbols-problem.html</guid>
        <pubDate>Wed, 11 Nov 2015 20:30:53 +0800</pubDate>
        <description>&lt;p&gt;在使用Instruments中的time profile调试QQMSF的时候，发现原先有的可以定位到具体函数的功能怎么也掉不出来。Instruments只能定位到一个函数地址，没有具体的函数名。分析应该是调试符号表没有找到的问题。于是去工程设置里面找关于这个选项。有几个地方需要注意：&lt;/p&gt;

&lt;h2 id=&quot;debug-information-format&quot;&gt;1 Debug information format&lt;/h2&gt;
&lt;p&gt;这里原先的设置是DWARF，什么是DWARF，他与熟悉的dSYM文件什么关系？查了一下。
“DWARF与dSYM的关系是，DWARF是文件格式，而dSYM往往指一个单独的文件。在Xcode中如果不做特殊制定，debug information是被保存在executable文件中，可以使用dsymutil从executable中提取dSYM文件。”&lt;/p&gt;

&lt;p&gt;将选项调整为，DWARF with dSYM File，再次使用Instruments来profile发现能够定位的具体的函数名。改问题解决。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/7df22103jw1exxbpoejnhj20fk057wep.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分析可能是Instruments工具回去读取调试目标匹配的dsym文件，而当输出调试信息格式使用dwarf时，调试信息输出在了执行文件中，没有输出到dsym文件中，导致Instruments工具无法读取dsym文件，找不到符号表，结果就是无法定位函数名了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2、编译优化选项&lt;/h2&gt;
&lt;p&gt;在调试的时候尽量，保持零优化的模式，这样能够保证符号表的完整性。关于具体调试选项的描述可以参考gcc的文档。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/7df22103jw1exxbqjncmrj20fk0b3aaq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZPullDownViewController</title>
        <link>http://dzpqzb.com/2015/11/11/dzpulldownviewcontroller.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzpulldownviewcontroller.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:46:08 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzpulldownviewcontrollerhttpsgithubcomyishuiliuniandzpulldownviewcontroller&quot;&gt;&lt;a href=&quot;https://github.com/yishuiliunian/DZPullDownViewController&quot;&gt;DZPullDownViewController&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;两层结构的视图控制器，下拉的时候，上层的视图滑动，显示出下层的视图。如果上层视图控制器的rootView是UIScrollView或其子类（比如UITableView），在滑到头的时候，继续往下拉，会显示出下面的视图。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZCDNFiles</title>
        <link>http://dzpqzb.com/2015/11/11/dzcdnfiles.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzcdnfiles.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:45:04 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzcdnfiles&quot;&gt;DZCDNFiles&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/DZCDNFiles&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/DZCDNFiles.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCDNFiles&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/DZCDNFiles.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCDNFiles&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/DZCDNFiles.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCDNFiles&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/DZCDNFiles.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从CDN拉取静态文件的库&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;DZCDNFiles is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod &quot;DZCDNFiles&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;DZCDNFiles is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>MSHttpRPC</title>
        <link>http://dzpqzb.com/2015/11/11/mshttprpc.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/mshttprpc.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:43:55 +0800</pubDate>
        <description>&lt;h1 id=&quot;mshttprpc&quot;&gt;MSHttpRPC&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/MSHttpRPC&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/MSHttpRPC.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSHttpRPC&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/MSHttpRPC.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSHttpRPC&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/MSHttpRPC.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSHttpRPC&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/MSHttpRPC.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;
#介绍
MSHttpRPC是一个简单基于Http的RPC框架,完成了主体的HTTP-RPC的CS交互的工作，用户可通过注册相应的关键性的Block来完成自定义的功能。已经完成了初步的RPC交互框架。
## Usage&lt;/p&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;MSHttpRPC is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
pod &quot;MSHttpRPC&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;MSHttpRPC is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>MSInputScrollViewController</title>
        <link>http://dzpqzb.com/2015/11/11/msinputscrollviewcontroller.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/msinputscrollviewcontroller.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:42:20 +0800</pubDate>
        <description>&lt;h1 id=&quot;msinputscrollviewcontroller&quot;&gt;MSInputScrollViewController&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/MSInputScrollViewController&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/MSInputScrollViewController.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSInputScrollViewController&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/MSInputScrollViewController.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSInputScrollViewController&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/MSInputScrollViewController.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoapods.org/pods/MSInputScrollViewController&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/MSInputScrollViewController.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;MSInputScrollViewController is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby
pod &quot;MSInputScrollViewController&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;MSInputScrollViewController is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>DZCache</title>
        <link>http://dzpqzb.com/2015/11/11/dzcache.html</link>
        <guid isPermaLink="true">http://dzpqzb.com/2015/11/11/dzcache.html</guid>
        <pubDate>Wed, 11 Nov 2015 19:41:41 +0800</pubDate>
        <description>&lt;h1 id=&quot;dzcache&quot;&gt;DZCache&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/stonedong/DZCache&quot;&gt;&lt;img src=&quot;http://img.shields.io/travis/stonedong/DZCache.svg?style=flat&quot; alt=&quot;CI Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCache&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/v/DZCache.svg?style=flat&quot; alt=&quot;Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCache&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/l/DZCache.svg?style=flat&quot; alt=&quot;License&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://cocoadocs.org/docsets/DZCache&quot;&gt;&lt;img src=&quot;https://img.shields.io/cocoapods/p/DZCache.svg?style=flat&quot; alt=&quot;Platform&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the Example directory first.&lt;/p&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;DZCache is available through &lt;a href=&quot;http://cocoapods.org&quot;&gt;CocoaPods&lt;/a&gt;. To install
it, simply add the following line to your Podfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod &quot;DZCache&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;stonedong, yishuiliunian@gmail.com&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;DZCache is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>