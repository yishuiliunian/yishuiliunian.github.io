---
title: 传输速度优化方案
date: 2017-10-17 16:39:29
tags:
---

## 包体积优化收益统计：

采样接口：

1. var_0 (post)
2. direct (get)
3. var_1 (post)

最开始优化传输包体积的目标来自于，网络速度优化。希望在带宽恒定的情况下，通过降低传输包体积来达到优化传输速率的目标。传输包大小，主要影响TCP传输的socket package数量。具体可以参考文章[TCP速率与窗口，带宽，RTT之间的关系](http://blog.csdn.net/bad_sheep/article/details/6158676)。
而TCP层传输的最大TCP包大小恒定，因而包体积对于速率的优化，只有当传输包大小达到一个特殊的边界值的时候才会对速度产生影响。但是可以肯定的是，当传输包体积越小，就越有可能传输较少的TCP socket package，就越有可能获得更快的速度。

而我们很容易意识到一个问题，传输包体积不是你说减，说减就能减的。必须在保证业务正常的情况下，才能去做优化。优化传输包体积首先我们需要量化优化目标。

我们为了与服务器进行一次数据交互过程，会制定上行协议和下行协议。而在执行协议的过程中，必然传输的数据中有一部分是业务逻辑直接相关的，而另外的是无直接关系的。比如支付接口，我们将和支付相关的订单信息等称之为业务逻辑直接相关的，而http层的一些header和cookies则称之为与业务逻辑无直接关系的。这里说上述问题是为了区分两个概念直接有效信息与辅助信息。为了让直接有效的支付信息能够在OP服务器发挥作用，我们添加了非常多的辅助信息，为了让支付信息能够顺利在OP中执行。


于是我们可以定义一个***信息负荷***的概念：

> 在一次数据交互的过程中，信息的整体数据量与有效信息部分的数据量之间的比率

因而我们很明显的知道信息负荷与以下因素有关：

1. 绝对信息负荷：信息的表达方式（json，pb还是urlencode，同样是int32类型，在不同的表达方式下消耗的数据量不一样）
2. 相对信息负荷；为传输有效信息而支付的辅助信息的多少

> 我们定义一个信息的标注负荷为其使用标准类型表示时所占用的数据量



而我们优化传输包体积的目标就是为了尽最大可能降低信息负荷。在保证业务逻辑正常的情况下，寻找降低信息负荷的方式。

## 采样目前主要接口信息负荷


| 接口                     | 信息负荷             |
|------------------------|------------------|
| var_0           | 3.45836575875486 |
| direct                 | 8                |
| var_1 | 8.11695906432749 |

### 负荷主要组成部分分析

目前主要业务参数为字符型表示，接口直接相关的数据，是第一部分负荷。该部分负荷，在目前阶段我们先假定不可压缩，是一个恒定的值。称之为信息固有负荷。

> 设固有负荷为Ifix，信息负荷为Iall

而称多余付出的资源为冗余负荷

```
 Ix = Iall - Ifix
```

而假设信息固有负荷不可降低的情况下，通过降低冗余负荷是一条可选路径。

| 接口                     | 冗余负荷             |
|------------------------|------------------|
| var_0           | 2.45836575875486 |
| direct                 | 7                |
| var_1 | 7.11695906432749 |



#### 冗余负荷组成分析

##### 钱包系统需要的公共参数


而在采样的几个接口中统计公共参数大小占比如下：

| 业务参数大小（与Body大小差异来自于=、&等拼接符号和数据处理的增幅） | 公共参数 | 公共参数占比 |
|--------------------------------------------------------------------|----------|--------------|
| 3311                                                               | 2026     | 61.19%       |
| 2342                                                               | 1945     | 83.05%       |
| 2266                                                               | 1924     | 84.91%       |

可以很直接的看出来，造成目前接口上行信息负荷较大的大头来自于公共参数部分。因而公共参数优化，将能够带来较大收益。


目前在上行接口参数中，公共从参数如下：

|关键字|长度（Bytes）|
|:--|:--|
|var_2|36|
|var_3|420|
|var_4|1071|
|ua|71|
|var_5|347|



![](http://ww3.sinaimg.cn/large/7df22103jw1f5aypwcu0cj20ku0hdwff.jpg)

可以看到var_4，var_3，var_5三个参数几乎占了公共参数的全部，换句话说，这三个参数是造成信息负荷较高的直接原因。其中var_3和var_5是一个值组成，而var_4是多值组成。

假设对于var_4,var_3,var_5做Session话缓存处理在理想状况下可以


|接口	|Request|	理想目标优化大小	| 理想优化空间|
|:--|:--|:--|
|var_0|	4444|	2026	|54.41%|
|direct	| 3176|	1945|	38.76%|
|var_1	|2776|	1924|	30.69%|


而若按照理想状态下优化则可得到信息负荷优化为：

|接口		|业务参数大小	|	目标优化大小	|信息负荷|
|:--|:--|:--|
|var_0	|	1285		|2418|	1.88171206225681|
|direct		|397	|	1231|	3.1007556675063|
|var_1|		342	|	852	|2.49122807017544|

可得信息符合优化理想效果为：

| 接口                   | 原始信息负荷 | 理想状态下优化后信息负荷 | 优化空间 |
|------------------------|--------------|--------------------------|----------|
| var_0           | 3.46         | 1.88                     | 45.59%   |
| direct                 | 8.00         | 3.10                     | 61.24%   |
| var_1 | 8.12         | 2.49                     | 69.31%   |



##### var_4内容分析

| 名称         | var_5   | 长度  | 占比   |
|-------------------------|--------|-----|---------|
| /应用的显示名           | var_6   | 63  | 9.62%   |
| 应用的var_7 identifier | var_7  | 60  | 9.16%   |
| 终端类型                | var_8 | 40  | 6.11%   |
| 设备唯一标识            | cuid_1   | 82  | 12.52%  |
| pass生成的设备唯一标识  | cuid_2    | 81  | 12.37%  |
| /设备指纹               | var_9    | 82  | 12.52%  |
| 是否越狱                | var_10      | 36  | 5.50%   |
| 用户指纹信息是否存在    | var_11      | 36  | 5.50%   |
|------华丽的分割线---------|
| 网络接入点              | nettype    | 39  | 5.95%   |
| /运营商                 | operator   | 40  | 6.11%   |
| 位置                    | wloc       | 60  | 9.16%   |
| ip                      | wmip    | 36  | 5.50%   |
| ip6                     | wmipv6   |     |         |


![](http://ww2.sinaimg.cn/large/7df22103jw1f5c7xo3fzaj20a40a3t8x.jpg)

上图也可以比较直接的看到非易变性数据在整个var_4中也占据了相当大的部分，对此部分作出Session化优化，之后将会有明显的收益。

而且***var_4中cuid_1参数与外层公共参数var_2重叠，可以考虑去掉一份***
##### HTTP层造成的冗余负荷

###### HTTP头部参数

采样的三个接口中纯HTTP头部的大小如下（对于Get请求，从URL中剔除业务参数和公共参数大小）

| 接口                   | Request | Header大小 | 减去业务参数大小 |
|------------------------|---------|------------|------------------|
| var_0           | 4444    | 784        | 784              |
| direct                 | 3176    | 3044       | 702              |
| var_1 | 2776    | 741        | 741              |

Header大小（减去业务部分）均方差为33.4896335536171，大小抖动范围为+-4.5%。因而可以推测，HTTP头部大小是个相对稳定的冗余负荷。仔细分析一下头部中的参数分布：

| var_5              | Value                                                            | var_5-Length | Value-Length | Total-Length |
|------------------|------------------------------------------------------------------|------------|--------------|--------------|
| .                | POST /_u/wireless/card_check HTTP/1.1                            | 1          | 37           | 38           |
| Host             | 10.95.40.58                                                      | 4          | 11           | 15           |
| Accept           | */*                                                              | 6          | 3            | 9            |
| Content-Type     | application/x-www-form-urlencoded; charset=utf-8                 | 12         | 48           | 60           |
| Connection       | keep-alive                                                       | 10         | 10           | 20           |
| gzip             | Content-Encoding                                                 | 4          | 16           | 20           |
| Proxy-Connection | keep-alive                                                       | 16         | 10           | 26           |
| Cookie           | var_12=9068512324620108035_00_6_R_R_1052_0303_c02f_Y; var_13={"group_smallflow":"smallflow","group_umoney":"umoney_test","group_smallflow_uri":""}; token=9e6813706b74430c9a4309375a64eb71; var_14=7A7E38E7E0BDF0EC2BD693A8D6B8B22B:FG=1; var_15=HlqM2hsbjZmS014ZmxOQlBGajlqTmluZ2g2Rn5oUjV4Q0hYSG1HLTRPbU40NUpYQVFBQUFBJCQAAAAAAAAAAAEAAABeqMoHeWlzaHVpbGl1bmlhbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI1Wa1eNVmtXa | 6                                                             | 408        | 414                    |
| User-Agent       | BaiduWallet-5.9.1.0-IOS-test_828_1472_iPhone_9.3.2_9.3.2_1.0_1.0 | 10         | 64           | 74           |
| Content-Length   | 2375                                                             | 14         | 4            | 18           |
| Accept-Language  | zh-cn                                                            | 15         | 5            | 20           |
| Accept-Encoding  | gzip, deflate                                                    | 15         | 13           | 28           |


其中绝大部分为HTTP层控制信息，是进行HTTP层传输必须配置的参数：

1. Host
2. Accept
3. Content-Type
4. Connection
5. gzip
6. Proxy-Connection
7. User-Agent
8. Content-Length
9. Accept-Language
10. Accept-Encoding

而参数***Cookies***为我们业务需求而产生的参数，并且在整体的头部信息中占到约59%的比例，也是不小的一块开支。因而按照对于公共参数的优化思路，首先寻找最优优化效果(对Cookies做全量剔除)：

| 接口                   | Request | Cookies理想优化 | 原始信息负荷     | 优化后信息负荷   | 优化空间 |
|------------------------|---------|-----------------|------------------|------------------|----------|
| var_0           | 4444    | 445             | 3.45836575875486 | 3.11206225680934 | 10.01%   |
| direct                 | 3176    | 399             | 8                | 6.99496221662469 | 12.56%   |
| var_1 | 2776    | 414             | 8.11695906432749 | 6.90643274853801 | 14.91%   |





##### HTTP Cokkies分析

| var_12         | 11041568683864785562_00_15_N_R_10_0303_c02f_Y                                                                                                                                                    | 5  | 45  | 50  |
|---------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----|-----|-----|
| var_13 | var_12=9068512324620108035_00_6_R_R_1052_0303_c02f_Y; var_13={"group_smallflow":"smallflow","group_umoney":"umoney_test","group_smallflow_uri":""}; token=9e6813706b74430c9a4309375a64eb71; var_14=7A7E38E7E0BDF0EC2BD693A8D6B8B22B:FG=1; var_15=HlqM2hsbjZmS014ZmxOQlBGajlqTmluZ2g2Rn5oUjV4Q0hYSG1HLTRPbU40NUpYQVFBQUFBJCQAAAAAAAAAAAEAAABeqMoHeWlzaHVpbGl1bmlhbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI1Wa1eNVmtXa                                                                                                                                                                                                | 13 | 85  | 98  |
| var_14       | 7A7E38E7E0BDF0EC2BD693A8D6B8B22B:FG=1                                                                                                                                                            | 7  | 37  | 44  |
| var_15         | HlqM2hsbjZmS014ZmxOQlBGajlqTmluZ2g2Rn5oUjV4Q0hYSG1HLTRPbU40NUpYQVFBQUFBJCQAAAAAAAAAAAEAAABeqMoHeWlzaHVpbGl1bmlhbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI1Wa1eNVmtXa | 5  | 192 | 197 |

其中var_14与var_15为登陆信息，而心在登陆信息绝大部分接口已经在公共参数中带上去了，这两个参数应该剔除掉，但是因为部分后台接口还会检查因而还留着，建议后台排查对应的接口，进行接口升级，剔除对于这两个参数的依赖。

而var_13做为AB测试使用的参数，目前在小流量中使用，这里也可以看一下是否可以使用其他方式来提供小流量分流操作，而不是使用var_13。

var_12这个参数未知，不知道种的，得排查一下。

###### UA在Header中以User-Agent存一份，而在参数中以UA存一份

方案：提出一份Uaser-Agent


###Session化方案

#### 策略1 Cookies策略，通过服务器和客户端维护相同的头部信息MD5来进行头部压缩
![](http://ww4.sinaimg.cn/large/7df22103jw1f6xr2im98fj20hk0kk752.jpg)
缓存合法性策略：客户端控制，最长10分钟内中内有效，10S分钟后采取更新策略

#### 策略2 使用HTTP2头部压缩策略

在HTTP1.1情况下使用HPACK算法传输头部，
在HTTP2情况下默认使用默认算法，不做头部压缩处理

![](screenshot.png)

效果参考：[HTTP/2 头部压缩技术介绍](https://imququ.com/post/header-compression-in-http2.html)



## 提高绝对信息负荷

##### 信息表达方式造成的冗余负荷（json与base64）


在第一轮加密之前：var_4数据原始数据长度：259

第一轮加密之后：var_4中Value大小：672

使用JSON表达之后：，var_5大小：70，整体大小890

使用Base64之后：整体大小1188

使用URLEncode之后大小：1190






| 原始数据     | 加密 | JSON   | Base64 | URLEncod |        |
|--------------|------|--------|--------|----------|--------|
| 大小         | 259  | 672    | 890    | 1188     | 1190   |
| 增幅         | 1    | 259.5% | 343.6% | 458.7%   | 459.5% |
| 相对增幅     | 0    | 159.5% | 32.4%  | 33.5%    | 0.2%   |
| 信息负荷     | 1    | 2.59   | 3.44   | 4.59     | 4.59   |
| 信息负荷增幅 | 0.0% | 159.5% | 32.4%  | 33.5%    | 0.2%   |

var_4中真正需要传输的数据为259Bytes，在经过加密，JSON化，Base64，URLEncode之后，数据量激增为1190。信息负荷提高459.5%。接近五倍。***因此var_4的处理方式需要升级***。同时，提出疑问Base64处理的意义何在？

####var_4升级策略一  JSON化后直接加密

||	原始数据|	JSON|	加密	|Base64|	URLEncod|
|--------------|------|--------|--------|----------|--------|
|大小	|259	|476|	652 |	872	|876|
|增幅	|1|	183.8%	|251.7%|	336.7%|	338.2%|
|相对增幅|	0	|83.8%|	37.0%|	33.7%|	0.5%|
|信息负荷	|1	|1.84|	2.52	|3.37	|3.38|
|信息负荷增幅|	0.0%|	83.8%	|37.0%|	33.7%|	0.5%|

调整顺序之后优化到：

| 处理前 | 处理后 | 优化 |    优化幅度     |
|--------|--------|------|---------|
| var_4    | 1190   | 876  | -26.39% |

####var_4升级策略二  Base64的必要性？

去掉Base64之后知道可以在前一步之上节省33%的体积,AES加密中，还有而外的一次Base64，这样实际上数据经过了两次base64处理，去掉一步之后，能有较好收益。

#### 空值优化
在接口中存在类似于下述形式的参数传输：

```
{
	"user":""
}
```
只有var_5而没有。


## 总结

主体策略分成两个：

1. 剔除无用数据传输
	1. 头部中无用数据提出
	2. 防止空值传输
2. 压缩有价值数据占用带宽
	1. Session化处理和头部压缩
	2. 协议变更
	3. 加密流程编程
